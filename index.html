<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TopDownSpace: Swarm Wars</title>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Press Start 2P', monospace;
            color: #fff;
        }
        #gameContainer {
            width: 80%;
            height: 90%;
            position: absolute;
            top: 5%;
            left: 10%;
            display: flex;
            border: 1px solid #fff;
        }
        canvas {
            border: 1px solid #fff;
            image-rendering: pixelated;
            flex-grow: 1;
        }
        #menu, #botMenu, #difficultyMenu, #howToPlayModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border: 2px solid #fff;
            box-shadow: 0 0 10px #fff;
            animation: glow 1.5s infinite alternate;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        @keyframes glow {
            0% { box-shadow: 0 0 5px #fff; }
            100% { box-shadow: 0 0 15px #fff; }
        }
        h1 {
            font-size: 32px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 7px #0ff;
            animation: flicker 0.1s infinite alternate;
        }
        @keyframes flicker {
            0% { opacity: 0.9; }
            100% { opacity: 1; }
        }
        button {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 7px 15px;
            margin: 7px 5px;
            background: #333;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 2px;
            width: 30%;
        }
        button:hover {
            background: #555;
            box-shadow: 0 0 10px #0ff;
        }
        #uiPanel {
            width: 100px;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border-left: 1px solid #fff;
            box-shadow: 0 0 5px #fff;
            z-index: 10;
            overflow-y: auto;
            display: none; /* Hidden in menu */
        }
        #uiPanel div {
            margin-bottom: 5px;
            padding: 2px;
            border-bottom: 1px solid #fff;
            font-size: 12px;
        }
        #howToPlayModal {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            max-height: 80%;
            overflow-y: auto;
        }
        #howToPlayModal.show {
            display: flex;
        }
        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
            animation: victoryGlow 1s infinite alternate;
        }
        @keyframes victoryGlow {
            0% { text-shadow: 0 0 5px #ff0; }
            100% { text-shadow: 0 0 15px #f00; }
        }
        #victoryScreen h1 {
            font-size: 24px;
            color: #ff0;
            text-shadow: 0 0 7px #f00;
            animation: victoryPulse 0.5s infinite alternate;
        }
        @keyframes victoryPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }
        #victoryScreen p {
            font-size: 12px;
            color: #0ff;
            margin: 5px 0;
        }
        #victoryScreen button {
            width: 20%;
            font-size: 8px;
        }
        @keyframes shake {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, 2px); }
            100% { transform: translate(0, 0); }
        }
        .shake {
            animation: shake 0.2s;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiPanel"></div>
    </div>
    <div id="menu">
        <h1>SWARM WARS</h1>
        <p style="font-size: 10px; margin: 10px 0;">Select Number of Players</p>
        <button onclick="showBotMenu(1)">1 Player</button>
        <button onclick="showBotMenu(2)">2 Players</button>
        <button onclick="showBotMenu(3)">3 Players</button>
        <button onclick="showHowToPlay()">How to Play</button>
        <button onclick="location.reload()" style="margin-top: 20px;">Back</button>
    </div>
    <div id="botMenu" style="display: none;">
        <h1>CONFIGURE BOTS</h1>
        <p style="font-size: 10px; margin: 10px 0;">Select Number of Bots (0-50)</p>
        <button onclick="showDifficultyMenu(0)">0 Bots</button>
        <button onclick="showDifficultyMenu(1)">1 Bot</button>
        <button onclick="showDifficultyMenu(2)">2 Bots</button>
        <button onclick="showDifficultyMenu(3)">3 Bots</button>
        <button onclick="showDifficultyMenu(5)">5 Bots</button>
        <button onclick="showDifficultyMenu(10)">10 Bots</button>
        <button onclick="showDifficultyMenu(15)">15 Bots</button>
        <button onclick="showDifficultyMenu(20)">20 Bots</button>
        <button onclick="showDifficultyMenu(50)">50 Bots</button>
        <button onclick="goBack()">Back</button>
    </div>
    <div id="difficultyMenu" style="display: none;">
        <h1>SELECT BOT DIFFICULTY</h1>
        <p style="font-size: 10px; margin: 10px 0;">Choose Difficulty Level</p>
        <button onclick="startGame(botCount, 'fortnite')">Fortnite Bot (Easy)</button>
        <button onclick="startGame(botCount, 'average')">Average Gamer (Medium)</button>
        <button onclick="startGame(botCount, 'fncs')">FNCS Champion (Hard)</button>
        <button onclick="startGame(botCount, 'ashton')">Ashton Hunt (Extreme)</button>
        <button onclick="goBack()">Back</button>
    </div>
    <div id="howToPlayModal">
        <h1>HOW TO PLAY</h1>
        <p style="font-size: 9px; margin: 10px 0; line-height: 1.5; background: rgba(255, 255, 255, 0.1); padding: 10px;">
            - <strong>Move:</strong> Use WASD (Player 1), Arrow Keys (Player 2), or IJKL (Player 3).<br>
            - <strong>Formation:</strong> Press E, Shift, or O to cycle formations.<br>
            - <strong>Dash:</strong> Press Q, /, or U (2s cooldown).<br>
            - <strong>Shooting:</strong> Automatic based on ship count.<br>
            - <strong>Power-Ups:</strong> Collect +2 to +20 ships.<br>
            - <strong>Avoid:</strong> Steer clear of asteroids and obstacles.<br>
            - <strong>Win:</strong> Be the last survivor!<br>
            <button onclick="hideHowToPlay()">Close</button>
        </p>
    </div>
    <div id="victoryScreen">
        <h1>ðŸ‘‘ VICTORY ROYALE! ðŸ‘‘</h1>
        <p id="winnerText"></p>
        <button onclick="restartGame()">Play Again</button>
    </div>
    <script>
        let playerCount = 0;
        let botCount = 0;
        let gameState = 'menu';
        let eliminations = [];
        let frameCount = 0;
        let countdownStart = 0;
        let countdownValue = 3;
        const MAX_BULLETS_PER_PLAYER = 50;
        const MAX_PARTICLES = 1200;
        const MAX_SHIPS_PER_PLAYER = 100;
        const PLAYER_SPEED = {
            max: 1.5,
            min: -0.75,
            acceleration: 0.075,
            deceleration: 0.95
        };
        const MIN_DISTANCE = 75;
        const ASTEROID_SPAWN_DISTANCE = 75;

        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const botMenu = document.getElementById('botMenu');
        const difficultyMenu = document.getElementById('difficultyMenu');
        const howToPlayModal = document.getElementById('howToPlayModal');
        const victoryScreen = document.getElementById('victoryScreen');
        const winnerText = document.getElementById('winnerText');
        const uiPanel = document.getElementById('uiPanel');

        const sidebarWidth = 100;
        const squareSize = Math.min(
            gameContainer.clientWidth - sidebarWidth,
            gameContainer.clientHeight
        );
        canvas.width = squareSize;
        canvas.height = squareSize;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency, duration, type = 'square', volume = 0.1) {
            const osc = audioCtx.createOscillator();
            osc.type = type;
            osc.frequency.value = frequency;
            const gain = audioCtx.createGain();
            gain.gain.value = volume;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }

        const players = [];
        const menuBots = [];
        const asteroids = [];
        const obstacles = [];
        const particles = [];
        const powerUps = [];
        const stars = [];
        const keys = {};
        const damageDisplays = [];
        let formationDisplays = [];
        const powerUpDisplays = [];
        const MAX_ASTEROIDS = 10;
        const GRID_SIZE = 20;
        const grid = {};

        function getGridCell(x, y) {
            return `${Math.floor(x / GRID_SIZE)},${Math.floor(y / GRID_SIZE)}`;
        }

        function showBotMenu(players) {
            playerCount = players;
            menu.style.display = 'none';
            botMenu.style.display = 'flex';
        }

        function showDifficultyMenu(bots) {
            botCount = bots;
            botMenu.style.display = 'none';
            if (botCount === 0) {
                startGame(0, null);
            } else {
                difficultyMenu.style.display = 'flex';
            }
        }

        function goBack() {
            if (difficultyMenu.style.display !== 'none') {
                difficultyMenu.style.display = 'none';
                botMenu.style.display = 'flex';
            } else if (botMenu.style.display !== 'none') {
                botMenu.style.display = 'none';
                menu.style.display = 'flex';
            }
        }

        function initMenuBots() {
            menuBots.length = 0;
            const positions = [];
            const getSafePosition = () => {
                let x, y;
                do {
                    x = Math.random() * (canvas.width - 25) + 12.5;
                    y = Math.random() * (canvas.height - 25) + 12.5;
                } while (positions.some(pos => Math.hypot(pos.x - x, pos.y - y) < MIN_DISTANCE));
                positions.push({ x, y });
                return { x, y };
            };

            for (let i = 0; i < 10; i++) {
                const pos = getSafePosition();
                menuBots.push({
                    ships: [{ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: Infinity, color: '#888', dx: (Math.random() - 0.5) * 0.25, dy: (Math.random() - 0.5) * 0.25 }],
                    keys: { up: '', down: '', left: '', right: '', form: '', dash: '' },
                    bullets: [],
                    alive: true,
                    formation: 'spiral',
                    lastShot: 0,
                    lastDash: 0,
                    dashEnd: 0,
                    dashSpeed: 0,
                    formationChangeSpeed: 0,
                    isBot: true,
                    difficulty: 'average'
                });
            }
        }

        function startGame(bots, difficulty) {
            botCount = bots;
            players.length = 0;
            menuBots.length = 0;
            asteroids.length = 0;
            obstacles.length = 0;
            particles.length = 0;
            powerUps.length = 0;
            damageDisplays.length = 0;
            formationDisplays.length = 0;
            powerUpDisplays.length = 0;
            Object.keys(grid).forEach(key => delete grid[key]);

            const positions = [];
            const getSafePosition = () => {
                let x, y;
                do {
                    x = Math.random() * (canvas.width - 25) + 12.5;
                    y = Math.random() * (canvas.height - 25) + 12.5;
                } while (positions.some(pos => Math.hypot(pos.x - x, pos.y - y) < MIN_DISTANCE));
                positions.push({ x, y });
                return { x, y };
            };

            const humanConfigs = [
                { keys: { up: 'w', down: 's', left: 'a', right: 'd', form: 'e', dash: 'q' }, color: '#f00' },
                { keys: { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', form: 'Shift', dash: '/' }, color: '#0f0' },
                { keys: { up: 'i', down: 'k', left: 'j', right: 'l', form: 'o', dash: 'u' }, color: '#00f' }
            ];
            for (let i = 0; i < playerCount; i++) {
                const pos = getSafePosition();
                players.push({
                    ships: [{ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: 200, color: humanConfigs[i].color, dx: (Math.random() - 0.5) * 0.25, dy: (Math.random() - 0.5) * 0.25 }],
                    keys: humanConfigs[i].keys,
                    bullets: [],
                    alive: true,
                    formation: 'spiral',
                    lastShot: 0,
                    lastDash: 0,
                    dashEnd: 0,
                    dashSpeed: 0,
                    formationChangeSpeed: 0,
                    isBot: false,
                    difficulty: 'player'
                });
            }

            const botStyles = {
                'fortnite': { style: 'defensive', baseColor: '#6666ff' },
                'average': { style: 'dashy', baseColor: '#66ff66' },
                'fncs': { style: 'aggressive', baseColor: '#ff6666' },
                'ashton': { style: 'formation', baseColor: '#ffcc66' }
            };
            for (let i = 0; i < botCount; i++) {
                const pos = getSafePosition();
                const botDifficulty = difficulty || 'average';
                const { style, baseColor } = botStyles[botDifficulty];
                players.push({
                    ships: [{ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: 200, color: baseColor, dx: (Math.random() - 0.5) * 0.25, dy: (Math.random() - 0.5) * 0.25 }],
                    keys: { up: '', down: '', left: '', right: '', form: '', dash: '' },
                    bullets: [],
                    alive: true,
                    formation: 'spiral',
                    lastShot: 0,
                    lastDash: 0,
                    dashEnd: 0,
                    dashSpeed: 0,
                    formationChangeSpeed: 0,
                    isBot: true,
                    difficulty: botDifficulty,
                    style: style
                });
            }

            gameState = 'countdown';
            countdownStart = Date.now();
            countdownValue = 3;
            menu.style.display = 'none';
            botMenu.style.display = 'none';
            difficultyMenu.style.display = 'none';
            victoryScreen.style.display = 'none';
            uiPanel.style.display = 'block';
            spawnObstacles();
            spawnStars();
            spawnNebula();
            spawnAsteroids();
            frameCount = 0;
        }

        function restartGame() {
            gameState = 'menu';
            victoryScreen.style.display = 'none';
            menu.style.display = 'flex';
            uiPanel.style.display = 'none';
            eliminations = [];
            players.length = 0;
            asteroids.length = 0;
            obstacles.length = 0;
            particles.length = 0;
            powerUps.length = 0;
            initMenuBots();
            frameCount = 0;
        }

        function drawShip(ship, totalEntities, isLead, isPlayer) {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            const size = Math.max(1, 10 - totalEntities * 0.01);
            ctx.fillStyle = ship.color;
            ctx.beginPath();
            ctx.moveTo(size, 0);
            ctx.lineTo(-size / 2, size / 2);
            ctx.lineTo(-size / 2, -size / 2);
            ctx.closePath();
            ctx.fill();
            if (ship.speed > 0 && Math.random() > 0.5) {
                ctx.fillStyle = '#ff0';
                ctx.fillRect(-size / 2 - 1, -size / 4, 1, size / 2);
            }
            if (isLead && isPlayer) {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(0, -size - 1);
                ctx.lineTo(1, -size);
                ctx.fill();
            }
            ctx.restore();
        }

        function showDamage(x, y, damage, color) {
            const offsetX = (Math.random() - 0.5) * 10;
            const offsetY = (Math.random() - 0.5) * 10;
            damageDisplays.push({ x: x + offsetX, y: y + offsetY - 2, damage, color, time: Date.now() });
        }

        function showFormation(x, y, formation, color) {
            formationDisplays = [{ x, y, formation, color, time: Date.now() }];
        }

        function showPowerUp(x, y, count, color) {
            powerUpDisplays.push({ x, y, text: `+${count} Ships!`, color, time: Date.now() });
        }

        function drawDamageFormationPowerUp() {
            damageDisplays.forEach((d, i) => {
                if (Date.now() - d.time > 500) {
                    damageDisplays.splice(i, 1);
                    return;
                }
                ctx.fillStyle = d.color;
                ctx.font = '6px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(`- ${d.damage}`, d.x, d.y);
            });
            formationDisplays.forEach((f, i) => {
                if (Date.now() - f.time > 2000) {
                    formationDisplays.splice(i, 1);
                    return;
                }
                ctx.fillStyle = f.color;
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(f.formation, f.x, f.y - 5);
            });
            powerUpDisplays.forEach((p, i) => {
                if (Date.now() - p.time > 2000) {
                    powerUpDisplays.splice(i, 1);
                    return;
                }
                ctx.fillStyle = p.color;
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(p.text, p.x, p.y - 5);
            });
        }

        function updatePlayer(player, index, isMenuBot = false) {
            if (!player.alive || !player.ships[0]) return;
            if (!isMenuBot && gameState !== 'playing' && gameState !== 'victory') return;
            const leadShip = player.ships[0];
            const { up, down, left, right, form, dash } = player.keys;

            let isForming = false;
            if (!player.isBot) {
                if (keys[up]) leadShip.speed = Math.min(leadShip.speed + PLAYER_SPEED.acceleration, PLAYER_SPEED.max);
                else if (keys[down]) leadShip.speed = Math.max(leadShip.speed - PLAYER_SPEED.acceleration, PLAYER_SPEED.min);
                else if (Date.now() > player.dashEnd) leadShip.speed *= PLAYER_SPEED.deceleration;
                if (keys[left]) leadShip.angle -= 0.1;
                if (keys[right]) leadShip.angle += 0.1;
                if (keys[form]) {
                    keys[form] = false;
                    player.formationChangeSpeed = leadShip.speed;
                    player.formation = getNextFormation(player.formation);
                    showFormation(leadShip.x, leadShip.y, player.formation, '#fff');
                    isForming = true;
                }
                if (keys[dash] && Date.now() - player.lastDash > 2000) {
                    player.dashSpeed = leadShip.speed + 4;
                    player.dashEnd = Date.now() + 200;
                    player.lastDash = Date.now();
                    playSound(1000, 0.2, 'triangle', 0.2);
                }
            } else {
                let targetPlayer = null;
                let minDistanceToPlayer = Infinity;
                const targetArray = isMenuBot ? menuBots : players;

                targetArray.forEach(p => {
                    if (p.alive && p !== player && p.ships.length > 0) {
                        const dist = Math.hypot(p.ships[0].x - leadShip.x, p.ships[0].y - leadShip.y);
                        if (dist < minDistanceToPlayer) {
                            minDistanceToPlayer = dist;
                            targetPlayer = p;
                        }
                    }
                });

                if (targetPlayer) {
                    const difficultySettings = {
                        'fortnite': { angleAdj: 0.1, lead: 0.05, dashChance: 0.01, formChance: 0.02 },
                        'average': { angleAdj: 0.2, lead: 0.1, dashChance: 0.025, formChance: 0.05 },
                        'fncs': { angleAdj: 0.6, lead: 0.2, dashChance: 0.075, formChance: 0.15 },
                        'ashton': { angleAdj: 1.0, lead: 0.3, dashChance: 0.1, formChance: 0.25 }
                    };
                    const settings = difficultySettings[player.difficulty] || difficultySettings['average'];

                    const styleAdjust = {
                        'aggressive': () => targetDistance < 50 ? 0.1 : 0,
                        'defensive': () => targetDistance > 75 ? -0.05 : 0,
                        'dashy': () => settings.dashChance * 2,
                        'formation': () => settings.formChance * 1.5
                    };
                    const styleMod = styleAdjust[player.style] || (() => 0);

                    let angleToTarget = Math.atan2(targetPlayer.ships[0].y - leadShip.y, targetPlayer.ships[0].x - leadShip.x);
                    if (player.difficulty === 'ashton') {
                        const targetDx = targetPlayer.ships[0].dx || 0;
                        const targetDy = targetPlayer.ships[0].dy || 0;
                        const dist = minDistanceToPlayer;
                        angleToTarget = Math.atan2(targetPlayer.ships[0].y + targetDy * dist * settings.lead - leadShip.y, targetPlayer.ships[0].x + targetDx * dist * settings.lead - leadShip.x);
                        leadShip.angle = angleToTarget;
                    } else {
                        const predictedX = targetPlayer.ships[0].x + (targetPlayer.ships[0].dx || 0) * settings.lead * minDistanceToPlayer;
                        const predictedY = targetPlayer.ships[0].y + (targetPlayer.ships[0].dy || 0) * settings.lead * minDistanceToPlayer;
                        angleToTarget = Math.atan2(predictedY - leadShip.y, predictedX - leadShip.x);
                        leadShip.angle += (angleToTarget - leadShip.angle) * settings.angleAdj;
                    }

                    const targetDistance = minDistanceToPlayer;
                    if (targetDistance > 50 + styleMod()) leadShip.speed = Math.min(leadShip.speed + PLAYER_SPEED.acceleration, PLAYER_SPEED.max);
                    else if (targetDistance < 40 + styleMod()) leadShip.speed = Math.max(leadShip.speed - PLAYER_SPEED.acceleration, PLAYER_SPEED.min);
                    else if (Date.now() > player.dashEnd) leadShip.speed *= PLAYER_SPEED.deceleration;

                    let avoidanceAngle = 0;
                    for (let a of asteroids) {
                        const distToAsteroid = Math.hypot(a.x - leadShip.x, a.y - leadShip.y);
                        if (distToAsteroid < a.size + 25) {
                            avoidanceAngle += (leadShip.x < a.x ? 0.3 : -0.3) * (player.difficulty === 'fncs' || player.difficulty === 'ashton' ? 2 : 1);
                        }
                    }
                    for (let o of obstacles) {
                        const distToObstacle = Math.hypot((o.x + o.w / 2) - leadShip.x, (o.y + o.h / 2) - leadShip.y);
                        if (distToObstacle < 30) {
                            avoidanceAngle += (leadShip.x < o.x + o.w / 2 ? 0.4 : -0.4) * (player.difficulty === 'fncs' || player.difficulty === 'ashton' ? 1.5 : 1);
                        }
                    }
                    for (let p of targetArray) {
                        if (p === player || !p.alive || p.ships.length === 0) continue;
                        for (let s of p.ships) {
                            const distToShip = Math.hypot(s.x - leadShip.x, s.y - leadShip.y);
                            if (distToShip < 30) {
                                avoidanceAngle += (leadShip.x < s.x ? 0.4 : -0.4) * (player.difficulty === 'fncs' || player.difficulty === 'ashton' ? 2 : 1);
                            }
                        }
                    }

                    const edgeMargin = 10;
                    if (leadShip.x < edgeMargin) avoidanceAngle += 0.5;
                    else if (leadShip.x > canvas.width - edgeMargin) avoidanceAngle -= 0.5;
                    if (leadShip.y < edgeMargin) avoidanceAngle += 0.5;
                    else if (leadShip.y > canvas.height - edgeMargin) avoidanceAngle -= 0.5;
                    if (leadShip.x < edgeMargin || leadShip.x > canvas.width - edgeMargin || leadShip.y < edgeMargin || leadShip.y > canvas.height - edgeMargin) {
                        leadShip.speed = Math.max(leadShip.speed - PLAYER_SPEED.acceleration, 0);
                    }

                    leadShip.angle += avoidanceAngle;

                    if (targetDistance < 75 && Date.now() - player.lastShot > 150 + player.ships.length * 3) {
                        player.ships.forEach(ship => {
                            if (player.bullets.length < MAX_BULLETS_PER_PLAYER) {
                                let shootAngle = ship.angle;
                                if (player.difficulty === 'fncs' || player.difficulty === 'ashton') {
                                    const dist = Math.hypot(targetPlayer.ships[0].x - ship.x, targetPlayer.ships[0].y - ship.y);
                                    const predictedX = targetPlayer.ships[0].x + (targetPlayer.ships[0].dx || 0) * settings.lead * dist;
                                    const predictedY = targetPlayer.ships[0].y + (targetPlayer.ships[0].dy || 0) * settings.lead * dist;
                                    shootAngle = Math.atan2(predictedY - ship.y, predictedX - ship.x);
                                }
                                player.bullets.push({
                                    x: ship.x + Math.cos(shootAngle) * 2,
                                    y: ship.y + Math.sin(shootAngle) * 2,
                                    dx: Math.cos(shootAngle) * 2,
                                    dy: Math.sin(shootAngle) * 2,
                                    color: ship.color,
                                    size: 1.5,
                                    time: Date.now(),
                                    shooter: player
                                });
                            }
                        });
                        player.lastShot = Date.now();
                        playSound(500, 0.1, 'square', 0.15);
                    }

                    const dashChance = settings.dashChance + styleMod();
                    if (Math.random() < dashChance && Date.now() - player.lastDash > 2000 && targetDistance > 50) {
                        player.dashSpeed = leadShip.speed + 4;
                        player.dashEnd = Date.now() + 200;
                        player.lastDash = Date.now();
                        playSound(1000, 0.2, 'triangle', 0.2);
                    }

                    const formChance = settings.formChance + styleMod();
                    if (Math.random() < formChance) {
                        player.formationChangeSpeed = leadShip.speed;
                        player.formation = getNextFormation(player.formation);
                        showFormation(leadShip.x, leadShip.y, player.formation, '#fff');
                        isForming = true;
                    }
                } else {
                    if (Date.now() > player.dashEnd) leadShip.speed *= PLAYER_SPEED.deceleration;
                    if (Math.random() < 0.1) leadShip.angle += (Math.random() - 0.5) * 0.2;
                }
            }

            if (Date.now() <= player.dashEnd) {
                leadShip.speed = player.dashSpeed;
                particles.push({
                    x: leadShip.x - Math.cos(leadShip.angle) * 2.5,
                    y: leadShip.y - Math.sin(leadShip.angle) * 2.5,
                    size: 0.75,
                    life: 20,
                    color: '#ff0',
                    dx: -Math.cos(leadShip.angle) * 0.5,
                    dy: -Math.sin(leadShip.angle) * 0.5
                });
            } else if (player.dashSpeed > 0) {
                player.dashSpeed *= 0.95;
                leadShip.speed = Math.max(leadShip.speed * 0.95, player.dashSpeed);
                if (player.dashSpeed < 0.05) player.dashSpeed = 0;
            }

            player.ships.forEach((ship, i) => {
                let targetX, targetY, offsetX, offsetY;
                if (i === 0) {
                    ship.dx = Math.cos(ship.angle) * ship.speed * 1.5;
                    ship.dy = Math.sin(ship.angle) * ship.speed * 1.5;
                } else {
                    const formations = {
                        'diamond': () => { offsetX = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 2.5; offsetY = i * 2.5; },
                        'compact': () => { const angle = (i / Math.min(player.ships.length, MAX_SHIPS_PER_PLAYER)) * Math.PI * 2; offsetX = Math.cos(angle) * 3.5; offsetY = Math.sin(angle) * 3.5; },
                        'swarm': () => { const angle = (i / Math.min(player.ships.length, MAX_SHIPS_PER_PLAYER)) * Math.PI * 2; offsetX = Math.cos(angle) * 7.5; offsetY = Math.sin(angle) * 7.5; },
                        'line-h': () => { offsetX = i * 5; offsetY = 0; },
                        'line-v': () => { offsetX = 0; offsetY = i * 5; },
                        'circle': () => { const angle = (i / Math.min(player.ships.length, MAX_SHIPS_PER_PLAYER)) * Math.PI * 2; offsetX = Math.cos(angle) * 5; offsetY = Math.sin(angle) * 5; },
                        'spiral': () => {
                            const radius = Math.min(10, i * 1);
                            const angle = i * 0.8;
                            offsetX = Math.cos(angle) * radius;
                            offsetY = Math.sin(angle) * radius;
                        }
                    };
                    formations[player.formation]();
                    targetX = leadShip.x - Math.cos(leadShip.angle) * offsetY - Math.sin(leadShip.angle) * offsetX;
                    targetY = leadShip.y - Math.sin(leadShip.angle) * offsetY + Math.cos(leadShip.angle) * offsetX;
                    ship.dx = (targetX - ship.x) * 0.2 * 1.5;
                    ship.dy = (targetY - ship.y) * 0.2 * 1.5;
                    ship.angle = leadShip.angle;

                    if (isForming) {
                        ship.speed = player.formationChangeSpeed;
                    } else {
                        ship.speed = leadShip.speed;
                    }
                }
                ship.dx *= 0.98;
                ship.dy *= 0.98;
                ship.x += ship.dx;
                ship.y += ship.dy;
                ship.x = Math.max(1, Math.min(canvas.width - 1, ship.x));
                ship.y = Math.max(1, Math.min(canvas.height - 1, ship.y));
                particles.push({
                    x: ship.x - Math.cos(ship.angle) * 1,
                    y: ship.y - Math.sin(ship.angle) * 1,
                    size: 0.15,
                    life: 8,
                    color: ship.color
                });
            });

            if (Date.now() - player.lastShot > 150 + player.ships.length * 3) {
                player.ships.forEach(ship => {
                    if (player.bullets.length < MAX_BULLETS_PER_PLAYER) {
                        player.bullets.push({
                            x: ship.x + Math.cos(ship.angle) * 2,
                            y: ship.y + Math.sin(ship.angle) * 2,
                            dx: Math.cos(ship.angle) * 2,
                            dy: Math.sin(ship.angle) * 2,
                            color: ship.color,
                            size: 1.5,
                            time: Date.now(),
                            shooter: player
                        });
                    }
                });
                player.lastShot = Date.now();
                playSound(500, 0.1, 'square', 0.15);
            }

            player.bullets = player.bullets.filter(b => {
                b.x += b.dx * 1.5;
                b.y += b.dy * 1.5;
                if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) return false;
                particles.push({ x: b.x - b.dx, y: b.y - b.dy, size: 0.15, life: 5, color: b.color });
                return Date.now() - b.time < 1500;
            });
        }

        function getNextFormation(current) {
            const formations = ['diamond', 'compact', 'swarm', 'line-h', 'line-v', 'circle', 'spiral'];
            const index = formations.indexOf(current);
            return formations[(index + 1) % formations.length];
        }

        function drawBullets(player) {
            player.bullets.forEach(b => {
                ctx.strokeStyle = b.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(b.x, b.y);
                const length = 5;
                const endX = b.x - b.dx * length / Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                const endY = b.y - b.dy * length / Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            });
        }

        function spawnAsteroids() {
            while (asteroids.length < MAX_ASTEROIDS) {
                let x, y;
                let tooClose;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                    tooClose = players.some(p => p.ships.some(s => Math.hypot(s.x - x, s.y - y) < ASTEROID_SPAWN_DISTANCE));
                } while (tooClose);
                asteroids.push({
                    x, y,
                    size: 5 + Math.random() * 10,
                    dx: (Math.random() - 0.5) * 1,
                    dy: (Math.random() - 0.5) * 1,
                    angle: 0,
                    spin: (Math.random() - 0.5) * 0.02,
                    hp: 500
                });
            }
        }

        function updateAsteroids() {
            asteroids.forEach(a => {
                if (gameState === 'playing') {
                    a.x += a.dx;
                    a.y += a.dy;
                    a.dx = Math.max(-1.5, Math.min(1.5, a.dx));
                    a.dy = Math.max(-1.5, Math.min(1.5, a.dy));
                    if (a.x - a.size < 0 || a.x + a.size > canvas.width) a.dx *= -1;
                    if (a.y - a.size < 0 || a.y + a.size > canvas.height) a.dy *= -1;
                }
                a.angle += a.spin;
                ctx.fillStyle = '#888';
                ctx.beginPath();
                for (let j = 0; j < 10; j++) {
                    const angle = a.angle + (Math.PI * 2 * j) / 10;
                    const r = a.size * (0.8 + Math.random() * 0.2);
                    ctx[j === 0 ? 'moveTo' : 'lineTo'](a.x + Math.cos(angle) * r, a.y + Math.sin(angle) * r);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        function spawnObstacles() {
            for (let i = 0; i < 2; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (players.some(p => p.ships.some(s => Math.hypot(s.x - x, s.y - y) < 25)));
                obstacles.push({
                    x, y,
                    w: 10 + Math.random() * 10,
                    h: 10 + Math.random() * 10,
                    hp: 1000
                });
            }
        }

        function drawObstacles() {
            obstacles.forEach(o => {
                ctx.fillStyle = '#555';
                ctx.fillRect(o.x, o.y, o.w, o.h);
            });
        }

        function spawnStars() {
            for (let i = 0; i < 300; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 0.25
                });
            }
        }

        function drawStars() {
            stars.forEach(s => {
                ctx.fillStyle = '#fff';
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });
        }

        const nebula = [];
        function spawnNebula() {
            for (let i = 0; i < 20; i++) {
                nebula.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 12.5 + Math.random() * 25,
                    color: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.1)`
                });
            }
        }

        function drawNebula() {
            nebula.forEach(n => {
                ctx.fillStyle = n.color;
                ctx.fillRect(n.x - n.size / 2, n.y - n.size / 2, n.size, n.size);
            });
        }

        function updateParticles() {
            if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
            particles.forEach((p, i) => {
                p.life--;
                if (p.dx) p.x += p.dx;
                if (p.dy) p.y += p.dy;
                p.dx = p.dx ? p.dx * 0.95 : 0;
                p.dy = p.dy ? p.dy * 0.95 : 0;
                if (p.life <= 0) particles.splice(i, 1);
                else {
                    ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.life / 40})`;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                }
            });
        }

        function spawnPowerUps() {
            if (Math.random() < 0.02) {
                const roll = Math.random();
                const type = roll < 0.2 ? '+2' : roll < 0.4 ? '+4' : roll < 0.6 ? '+6' : roll < 0.8 ? '+8' : roll < 0.95 ? '+10' : '+20';
                powerUps.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    type,
                    pulse: 0,
                    pulseDirection: 1
                });
            }
        }

        function updatePowerUps() {
            powerUps.forEach((pu, i) => {
                pu.pulse += pu.pulseDirection * 0.1;
                if (pu.pulse >= 1) pu.pulseDirection = -1;
                if (pu.pulse <= 0) pu.pulseDirection = 1;
                const radius = 5 + pu.pulse * 1.5;

                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(pu.x, pu.y, radius + 2.5, 0, Math.PI * 2);
                ctx.fill();

                const gradient = ctx.createRadialGradient(pu.x, pu.y, 0, pu.x, pu.y, radius);
                gradient.addColorStop(0, '#ff0');
                gradient.addColorStop(1, '#ffa500');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pu.x, pu.y, radius, 0, Math.PI * 2);
                ctx.fill();

                if (Math.random() < 0.3) {
                    particles.push({
                        x: pu.x + (Math.random() - 0.5) * radius * 2,
                        y: pu.y + (Math.random() - 0.5) * radius * 2,
                        size: 1,
                        life: 20,
                        color: '#fff',
                        dx: (Math.random() - 0.5) * 1,
                        dy: (Math.random() - 0.5) * 1
                    });
                }

                ctx.fillStyle = '#000';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(pu.type, pu.x, pu.y + 2);

                players.forEach(p => {
                    p.ships.forEach(s => {
                        if (Math.hypot(s.x - pu.x, s.y - pu.y) < radius && p.ships.length < MAX_SHIPS_PER_PLAYER) {
                            const count = Math.min(parseInt(pu.type.slice(1)), MAX_SHIPS_PER_PLAYER - p.ships.length);
                            for (let j = 0; j < count; j++) {
                                p.ships.push({ x: s.x, y: s.y, angle: s.angle, speed: 0, hp: 100, color: s.color, dx: 0, dy: 0 });
                                playSound(800, 0.2, 'triangle', 0.1);
                            }
                            showPowerUp(pu.x, pu.y, count, '#0f0');
                            powerUps.splice(i, 1);
                            playSound(600, 0.3, 'sine', 0.2);
                        }
                    });
                });
            });
        }

        function explosion(x, y, count, baseColor = '#ff0', size = 2, isFinal = false) {
            const colors = ['#ff0', '#f00', '#0f0', '#00f', '#fff'];
            for (let i = 0; i < Math.min(count * 2, MAX_PARTICLES - particles.length); i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                const particleSize = size + Math.random() * 1.5;
                particles.push({
                    x, y,
                    size: particleSize,
                    life: 60,
                    color,
                    dx: (Math.random() - 0.5) * 6,
                    dy: (Math.random() - 0.5) * 6
                });
            }
            if (isFinal) {
                for (let i = 0; i < Math.min(count, MAX_PARTICLES - particles.length); i++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    particles.push({
                        x, y,
                        size: 1 + Math.random() * 1,
                        life: 90,
                        color,
                        dx: (Math.random() - 0.5) * 3,
                        dy: (Math.random() - 0.5) * 3
                    });
                }
            }
            playSound(80, 0.5, 'sine', 0.2);
        }

        function checkCollisions() {
            Object.keys(grid).forEach(key => delete grid[key]);
            players.forEach(p => {
                if (p.ships && p.ships.length > 0) {
                    p.ships.forEach(s => {
                        const cell = getGridCell(s.x, s.y);
                        grid[cell] = grid[cell] || [];
                        grid[cell].push(s);
                    });
                }
            });
            asteroids.forEach(a => {
                const cell = getGridCell(a.x, a.y);
                grid[cell] = grid[cell] || [];
                grid[cell].push(a);
            });
            obstacles.forEach(o => {
                const cell = getGridCell(o.x + o.w / 2, o.y + o.h / 2);
                grid[cell] = grid[cell] || [];
                grid[cell].push(o);
            });

            for (let pi = 0; pi < players.length; pi++) {
                const p = players[pi];
                if (!p.ships || p.ships.length === 0) continue;
                for (let bi = p.bullets.length - 1; bi >= 0; bi--) {
                    const b = p.bullets[bi];
                    const cell = getGridCell(b.x, b.y);
                    const nearby = grid[cell] || [];
                    const adjacentCells = [
                        cell,
                        getGridCell(b.x + GRID_SIZE, b.y),
                        getGridCell(b.x - GRID_SIZE, b.y),
                        getGridCell(b.x, b.y + GRID_SIZE),
                        getGridCell(b.x, b.y - GRID_SIZE),
                        getGridCell(b.x + GRID_SIZE, b.y + GRID_SIZE),
                        getGridCell(b.x + GRID_SIZE, b.y - GRID_SIZE),
                        getGridCell(b.x - GRID_SIZE, b.y + GRID_SIZE),
                        getGridCell(b.x - GRID_SIZE, b.y - GRID_SIZE)
                    ].filter(c => grid[c]);

                    const entities = [...new Set([].concat(...adjacentCells.map(c => grid[c])))];
                    entities.forEach(entity => {
                        if (entity && entity.hp && entity.angle && 'color' in entity) {
                            const s = entity;
                            const targetPlayer = players.find(pl => pl.ships.includes(s));
                            if (targetPlayer && b.shooter !== targetPlayer) {
                                const dist = Math.hypot(s.x - b.x, s.y - b.y);
                                if (dist < 6) {
                                    s.hp -= 30;
                                    s.dx -= b.dx * 0.05;
                                    s.dy -= b.dy * 0.05;
                                    showDamage(s.x, s.y, 30, s.color);
                                    explosion(b.x, b.y, 5, s.color);
                                    if (s.hp <= 0) {
                                        const ownerPlayer = targetPlayer;
                                        if (ownerPlayer) {
                                            const si = ownerPlayer.ships.indexOf(s);
                                            if (si > -1) ownerPlayer.ships.splice(si, 1);
                                            explosion(s.x, s.y, 40, s.color);
                                        }
                                    }
                                    p.bullets.splice(bi, 1);
                                    return;
                                }
                            }
                        }
                    });
                }
            }

            for (let pi = 0; pi < players.length; pi++) {
                const p = players[pi];
                if (!p.ships || p.ships.length === 0) continue;

                for (let si = p.ships.length - 1; si >= 0; si--) {
                    const s = p.ships[si];
                    const cell = getGridCell(s.x, s.y);
                    const nearby = grid[cell] || [];
                    const adjacentCells = [
                        cell,
                        getGridCell(s.x + GRID_SIZE, s.y),
                        getGridCell(s.x - GRID_SIZE, s.y),
                        getGridCell(s.x, s.y + GRID_SIZE),
                        getGridCell(s.x, s.y - GRID_SIZE),
                        getGridCell(s.x + GRID_SIZE, s.y + GRID_SIZE),
                        getGridCell(s.x + GRID_SIZE, s.y - GRID_SIZE),
                        getGridCell(s.x - GRID_SIZE, s.y + GRID_SIZE),
                        getGridCell(s.x - GRID_SIZE, s.y - GRID_SIZE)
                    ].filter(c => grid[c]);

                    const entities = [...new Set([].concat(...adjacentCells.map(c => grid[c])))];
                    entities.forEach(entity => {
                        if (entity && entity.hp && entity.angle && entity !== s) {
                            const os = entity;
                            const op = players.find(pl => pl.ships.includes(os));
                            if (!op || op === p || !op.alive) return;

                            const dist = Math.hypot(s.x - os.x, s.y - os.y);
                            const shipSize = Math.max(1, 10 - p.ships.length * 0.01);
                            if (dist < shipSize) {
                                const speed = Math.sqrt(s.dx * s.dx + s.dy * s.dy) + Math.sqrt(os.dx * os.dx + os.dy * os.dy);
                                const damage = Math.floor(speed * 4);
                                s.hp -= damage;
                                os.hp -= damage;
                                showDamage(s.x, s.y, damage, s.color);
                                showDamage(os.x, os.y, damage, os.color);
                                explosion(s.x, s.y, 10, s.color);

                                const dx = s.x - os.x;
                                const dy = s.y - os.y;
                                const distActual = Math.hypot(dx, dy) || 1;
                                const pushForce = 0.1;
                                s.dx += (dx / distActual) * pushForce;
                                s.dy += (dy / distActual) * pushForce;
                                os.dx -= (dx / distActual) * pushForce;
                                os.dy -= (dy / distActual) * pushForce;

                                if (s.hp <= 0) {
                                    p.ships.splice(si, 1);
                                    explosion(s.x, s.y, 40, s.color);
                                }
                                if (os.hp <= 0) {
                                    const osi = op.ships.indexOf(os);
                                    if (osi > -1) op.ships.splice(osi, 1);
                                    explosion(os.x, os.y, 40, os.color);
                                }
                                playSound(100, 0.5, 'sine', 0.3);
                                return;
                            }
                        }
                    });

                    if (p.ships.length === 0 && p.alive) {
                        p.alive = false;
                        p.bullets = [];
                        eliminations.push({ text: `${p.isBot ? 'BOT' : 'PLAYER'} ${pi + 1} ELIMINATED`, time: Date.now(), opacity: 1 });
                        const deathX = p.ships[0]?.x || canvas.width / 2;
                        const deathY = p.ships[0]?.y || canvas.height / 2;
                        const deathColor = p.ships[0]?.color || '#fff';
                        const aliveCount = players.filter(p => p.alive).length;
                        if (aliveCount === 1) {
                            explosion(deathX, deathY, 1200, deathColor, 4, true);
                        } else {
                            explosion(deathX, deathY, 400, deathColor, 3);
                        }
                        playSound(200, 1.0, 'sine', 0.3);
                    }
                }
            }

            for (let pi = 0; pi < players.length; pi++) {
                const p = players[pi];
                for (let si = p.ships.length - 1; si >= 0; si--) {
                    const s = p.ships[si];
                    const cell = getGridCell(s.x, s.y);
                    const nearby = grid[cell] || [];
                    const adjacentCells = [
                        cell,
                        getGridCell(s.x + GRID_SIZE, s.y),
                        getGridCell(s.x - GRID_SIZE, s.y),
                        getGridCell(s.x, s.y + GRID_SIZE),
                        getGridCell(s.x, s.y - GRID_SIZE),
                        getGridCell(s.x + GRID_SIZE, s.y + GRID_SIZE),
                        getGridCell(s.x + GRID_SIZE, s.y - GRID_SIZE),
                        getGridCell(s.x - GRID_SIZE, s.y + GRID_SIZE),
                        getGridCell(s.x - GRID_SIZE, s.y - GRID_SIZE)
                    ].filter(c => grid[c]);

                    const entities = [...new Set([].concat(...adjacentCells.map(c => grid[c])))];
                    entities.forEach(entity => {
                        if (entity.hp && entity.size) {
                            const a = entity;
                            const dist = Math.hypot(s.x - a.x, s.y - a.y);
                            if (dist < a.size + 1.5) {
                                s.hp -= 5;
                                showDamage(s.x, s.y, 5, s.color);

                                const dx = s.x - a.x;
                                const dy = s.y - a.y;
                                const distActual = Math.hypot(dx, dy) || 1;
                                const overlap = (a.size + 1.5) - distActual;
                                if (overlap > 0) {
                                    s.x += (dx / distActual) * overlap * 0.5;
                                    s.y += (dy / distActual) * overlap * 0.5;
                                    s.dx += (dx / distActual) * 0.05;
                                    s.dy += (dy / distActual) * 0.05;
                                }

                                if (s.hp <= 0) {
                                    p.ships.splice(si, 1);
                                    explosion(s.x, s.y, 40, s.color);
                                }
                                a.hp -= 10;
                                showDamage(a.x, a.y, 10, '#888');
                                if (a.hp <= 0) {
                                    if (a.size > 5) {
                                        const splitCount = Math.min(3, Math.floor(Math.sqrt(s.dx * s.dx + s.dy * s.dy) / 2) + 1);
                                        for (let i = 0; i < splitCount; i++) {
                                            asteroids.push({
                                                x: a.x,
                                                y: a.y,
                                                size: Math.max(5, a.size / splitCount),
                                                dx: a.dx + (Math.random() - 0.5) * 0.5,
                                                dy: a.dy + (Math.random() - 0.5) * 0.5,
                                                angle: 0,
                                                spin: (Math.random() - 0.5) * 0.02,
                                                hp: 500
                                            });
                                        }
                                    }
                                    const index = asteroids.indexOf(a);
                                    if (index > -1) asteroids.splice(index, 1);
                                    explosion(a.x, a.y, 60);
                                    playSound(300, 0.3, 'sine', 0.2);
                                }
                                return;
                            }
                        } else if (entity.w && entity.h) {
                            const o = entity;
                            if (s.x > o.x && s.x < o.x + o.w && s.y > o.y && s.y < o.y + o.h) {
                                s.hp -= 15;
                                showDamage(s.x, s.y, 15, s.color);

                                const closestEdgeX = s.x < o.x + o.w / 2 ? o.x : o.x + o.w;
                                const closestEdgeY = s.y < o.y + o.h / 2 ? o.y : o.y + o.h;
                                const dx = s.x - closestEdgeX;
                                const dy = s.y - closestEdgeY;
                                const dist = Math.hypot(dx, dy) || 1;
                                s.x += (dx / dist) * 0.1;
                                s.y += (dy / dist) * 0.1;

                                if (s.hp <= 0) {
                                    p.ships.splice(si, 1);
                                    explosion(s.x, s.y, 40, s.color);
                                }
                                o.hp -= 20;
                                showDamage(o.x + o.w / 2, o.y, 20, '#555');
                                if (o.hp <= 0) {
                                    const index = obstacles.indexOf(o);
                                    if (index > -1) obstacles.splice(index, 1);
                                }
                                return;
                            }
                        }
                    });
                }
            }

            for (let pi = 0; pi < players.length; pi++) {
                const p = players[pi];
                for (let bi = p.bullets.length - 1; bi >= 0; bi--) {
                    const b = p.bullets[bi];
                    const cell = getGridCell(b.x, b.y);
                    const nearby = grid[cell] || [];
                    const adjacentCells = [
                        cell,
                        getGridCell(b.x + GRID_SIZE, b.y),
                        getGridCell(b.x - GRID_SIZE, b.y),
                        getGridCell(b.x, b.y + GRID_SIZE),
                        getGridCell(b.x, b.y - GRID_SIZE),
                        getGridCell(b.x + GRID_SIZE, b.y + GRID_SIZE),
                        getGridCell(b.x + GRID_SIZE, b.y - GRID_SIZE),
                        getGridCell(b.x - GRID_SIZE, b.y + GRID_SIZE),
                        getGridCell(b.x - GRID_SIZE, b.y - GRID_SIZE)
                    ].filter(c => grid[c]);

                    const entities = [...new Set([].concat(...adjacentCells.map(c => grid[c])))];
                    entities.forEach(entity => {
                        if (entity.hp && entity.size) {
                            const a = entity;
                            if (Math.hypot(b.x - a.x, b.y - a.y) < a.size) {
                                a.hp -= 20;
                                showDamage(a.x, a.y, 20, '#888');
                                if (a.hp <= 0) {
                                    if (a.size > 5) {
                                        const splitCount = Math.min(3, Math.floor(Math.sqrt(b.dx * b.dx + b.dy * b.dy) / 2) + 1);
                                        for (let i = 0; i < splitCount; i++) {
                                            asteroids.push({
                                                x: a.x,
                                                y: a.y,
                                                size: Math.max(5, a.size / splitCount),
                                                dx: a.dx + (Math.random() - 0.5) * 0.5,
                                                dy: a.dy + (Math.random() - 0.5) * 0.5,
                                                angle: 0,
                                                spin: (Math.random() - 0.5) * 0.02,
                                                hp: 500
                                            });
                                        }
                                    }
                                    const index = asteroids.indexOf(a);
                                    if (index > -1) asteroids.splice(index, 1);
                                    explosion(a.x, a.y, 60);
                                    playSound(300, 0.3, 'sine', 0.2);
                                }
                                p.bullets.splice(bi, 1);
                                return;
                            }
                        } else if (entity.w && entity.h) {
                            const o = entity;
                            if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) {
                                o.hp -= 20;
                                showDamage(o.x + o.w / 2, o.y, 20, '#555');
                                if (o.hp <= 0) {
                                    const index = obstacles.indexOf(o);
                                    if (index > -1) obstacles.splice(index, 1);
                                }
                                p.bullets.splice(bi, 1);
                                return;
                            }
                        }
                    });
                }
            }
        }

        function drawUI() {
            uiPanel.innerHTML = '';
            const baseFontSize = 12;
            const fontSize = Math.max(8, baseFontSize - Math.max(0, players.length - 10) * 0.5);
            const sortedPlayers = [...players].sort((a, b) => {
                const hpA = a.ships.reduce((sum, ship) => sum + (ship.hp || 0), 0);
                const hpB = b.ships.reduce((sum, ship) => sum + (ship.hp || 0), 0);
                return hpB - hpA;
            });

            sortedPlayers.forEach((p, i) => {
                const totalHP = p.ships.reduce((sum, ship) => sum + (ship.hp || 0), 0);
                const div = document.createElement('div');
                let className = '';
                if (!p.alive) {
                    explosion(canvas.width - 50, i * 20 + 10, 20, p.ships[0]?.color || '#fff');
                    div.style.display = 'none';
                } else if (damageDisplays.some(d => d.color === p.ships[0]?.color && Date.now() - d.time < 200)) {
                    className = 'shake';
                }
                div.innerHTML = `
                    <p class="${className}">${p.isBot ? 'Bot' : 'Player'} ${players.indexOf(p) + 1}</p>
                    <p>HP: ${totalHP}</p>
                    <p>Ships: ${p.ships.length}</p>
                `;
                div.style.fontSize = `${fontSize}px`;
                uiPanel.appendChild(div);
            });

            const alivePlayers = players.filter(p => p.alive && p.ships && p.ships.length > 0);
            if (alivePlayers.length === 1 && gameState === 'playing') {
                gameState = 'victory';
                const winner = alivePlayers[0];
                const winnerIndex = players.indexOf(winner) + 1;
                winnerText.textContent = `${winner.isBot ? 'BOT' : 'PLAYER'} ${winnerIndex} WINS!`;
                victoryScreen.style.display = 'flex';
                playSound(1000, 1.0, 'sine', 0.3);
            }

            eliminations = eliminations.filter(e => Date.now() - e.time < 5000);
            eliminations.forEach((e, i) => {
                const elapsed = Date.now() - e.time;
                e.opacity = Math.max(0, 1 - elapsed / 5000);
                ctx.fillStyle = `rgba(255, 255, 255, ${e.opacity})`;
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(e.text, canvas.width / 2, canvas.height / 2 - 20 + i * 7.5);
            });
            drawDamageFormationPowerUp();
        }
                function gameLoop() {
            ctx.save();
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'menu') {
                menuBots.forEach((bot, i) => updatePlayer(bot, i, true));
                menuBots.forEach(bot => bot.ships.forEach((ship, j) => drawShip(ship, bot.ships.length, j === 0)));
                menuBots.forEach(bot => drawBullets(bot));
                drawNebula();
                drawStars();
            } else if (gameState === 'countdown') {
                const elapsed = (Date.now() - countdownStart) / 1000;
                countdownValue = Math.max(0, 3 - Math.floor(elapsed));
                ctx.fillStyle = '#fff';
                ctx.font = '24px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(countdownValue > 0 ? countdownValue : 'GO!', canvas.width / 2, canvas.height / 2);
                if (countdownValue === 0 && elapsed > 3.5) gameState = 'playing';
                drawNebula();
                drawStars();
                players.forEach((p, i) => updatePlayer(p, i));
                players.forEach(p => p.ships.forEach((s, j) => drawShip(s, p.ships.length, j === 0, !p.isBot)));
                updateAsteroids();
                drawObstacles();
            } else if (gameState === 'playing' || gameState === 'victory') {
                drawNebula();
                drawStars();
                players.forEach((p, i) => updatePlayer(p, i));
                players.forEach(p => p.ships.forEach((s, j) => drawShip(s, p.ships.length, j === 0, !p.isBot)));
                players.forEach(p => drawBullets(p));
                updateAsteroids();
                drawObstacles();
                updateParticles();
                spawnPowerUps();
                updatePowerUps();
                checkCollisions();
                drawUI();
            }

            ctx.restore();
            frameCount++;
            requestAnimationFrame(gameLoop);
        }

        function showHowToPlay() {
            howToPlayModal.classList.add('show');
            menu.style.display = 'none';
        }

        function hideHowToPlay() {
            howToPlayModal.classList.remove('show');
            menu.style.display = 'flex';
        }

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        initMenuBots();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
