<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TopDownSpace</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link id="favicon" rel="icon" type="image/png" href="https://topdownspace.github.io/favicon-32x32.png">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6598513151197899"
     crossorigin="anonymous"></script>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0a23, #1a1a4d);
            font-family: 'Orbitron', sans-serif;
            color: #fff;
        }
        #gameContainer {
            width: 85%;
            height: 95%;
            position: absolute;
            top: 2.5%;
            left: 7.5%;
            display: flex;
            background: radial-gradient(circle, rgba(0, 0, 50, 0.8), rgba(0, 0, 20, 1));
            border: 2px solid #00ccff;
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.5);
            border-radius: 10px;
        }
        canvas {
            border: 1px solid #00ccff;
            image-rendering: optimizeSpeed;
            flex-grow: 1;
            background: transparent;
        }
        #menu, #botMenu, #difficultyMenu, #moduleMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            text-align: center;
            background: rgba(10, 10, 50, 0.9);
            padding: 20px;
            border: 2px solid #00ccff;
            box-shadow: 0 0 20px #00ccff;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 10px #00ccff; }
            50% { box-shadow: 0 0 30px #00ccff; }
            100% { box-shadow: 0 0 10px #00ccff; }
        }
        h1 {
            font-size: 48px;
            margin: 0 0 30px 0;
            text-shadow: 0 0 15px #00ccff, 0 0 25px #00ffcc;
            animation: glowText 1.5s infinite alternate;
        }
        @keyframes glowText {
            0% { text-shadow: 0 0 10px #00ccff; }
            100% { text-shadow: 0 0 20px #00ffcc; }
        }
        button {
            position: relative;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            padding: 10px 20px;
            margin: 10px;
            background: linear-gradient(45deg, #00ccff, #0077b6);
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
            width: 200px;
            overflow: hidden;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.8);
        }
        button.clicked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 2px;
            background: #ffcc00;
            transform: translate(-50%, -50%);
            animation: bulletHit 0.3s forwards;
        }
        @keyframes bulletHit {
            0% { width: 10px; opacity: 1; }
            100% { width: 0; opacity: 0; }
        }
        #uiPanel {
            width: 150px;
            height: 100%;
            background: rgba(0, 0, 50, 0.9);
            padding: 10px;
            border-left: 2px solid #00ccff;
            box-shadow: -5px 0 15px rgba(0, 204, 255, 0.3);
            z-index: 10;
            overflow-y: auto;
            display: none;
            font-size: 12px;
        }
        #uiPanel div {
            margin-bottom: 10px;
            padding: 5px;
            border-bottom: 1px solid rgba(0, 204, 255, 0.5);
            text-shadow: 0 0 5px #00ccff;
        }
        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(0, 0, 50, 0.9), transparent);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
            animation: victoryGlow 1s infinite alternate;
        }
        @keyframes victoryGlow {
            0% { text-shadow: 0 0 10px #ffcc00; transform: scale(1); }
            100% { text-shadow: 0 0 20px #ff3333; transform: scale(1.05); }
        }
        #victoryScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            animation: spin 2s infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #victoryScreen p {
            font-size: 18px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ffcc00;
        }
        #victoryScreen button {
            background: linear-gradient(45deg, #ffcc00, #ff3333);
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        #victoryScreen button:hover {
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.8);
        }
        #faviconOptions {
            display: none;
            flex-direction: column;
        }
        #moduleChecklist {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: rgba(0, 0, 50, 0.8);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
        }
        #moduleChecklist label {
            margin: 5px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            position: relative;
        }
        #moduleChecklist input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        #moduleChecklist .tooltip {
            visibility: hidden;
            width: 200px;
            background: rgba(0, 0, 50, 0.9);
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            top: -5px;
            left: 110%;
            font-size: 12px;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }
        #moduleChecklist label:hover .tooltip {
            visibility: visible;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiPanel"></div>
    </div>
    <div id="menu">
        <h1>TopDownSpace .github.io</h1>
        <button onclick="showBotMenu(1)">1 Player</button>
        <button onclick="showBotMenu(2)">2 Players</button>
        <button onclick="showBotMenu(3)">3 Players</button>
        <button onclick="window.location.href='https://topdownspace.github.io/how-to-play.html'">How to Play</button>
        <button id="toggleNewTabButton" onclick="toggleNewTab()">Toggle New Tab On</button>
        <div id="faviconOptions">
            <button onclick="setFavicon('light')">Light Favicon</button>
            <button onclick="setFavicon('dark')">Dark Favicon</button>
        </div>
    </div>
    <div id="botMenu" style="display: none;">
        <h1>Select Bot Count</h1>
        <button onclick="showDifficultyMenu(0)">0 Bots</button>
        <button onclick="showDifficultyMenu(1)">1 Bot</button>
        <button onclick="showDifficultyMenu(2)">2 Bots</button>
        <button onclick="showDifficultyMenu(3)">3 Bots</button>
        <button onclick="showDifficultyMenu(4)">4 Bots</button>
        <button onclick="showDifficultyMenu(5)">5 Bots</button>
        <button onclick="showDifficultyMenu(6)">6 Bots</button>
        <button onclick="showDifficultyMenu(7)">7 Bots</button>
        <button onclick="showDifficultyMenu(8)">8 Bots</button>
        <button onclick="showDifficultyMenu(50)">50 Bots</button>
        <button onclick="showDifficultyMenu(100)">100 Bots</button>
        <button onclick="goBack()">Back</button>
    </div>
    <div id="difficultyMenu" style="display: none;">
        <h1>Select Bot Difficulty</h1>
        <button onclick="showModuleMenu('novice')">Novice</button>
        <button onclick="showModuleMenu('standard')">Standard</button>
        <button onclick="showModuleMenu('elite')">Elite</button>
        <button onclick="showModuleMenu('Deity')">Deity</button>
        <button onclick="goBack()">Back</button>
    </div>
    <div id="moduleMenu" style="display: none;">
        <h1>What Modules?</h1>
        <div id="moduleChecklist"></div>
        <button onclick="startGame(botCount, true)">Start with Modules</button>
        <button onclick="startGame(botCount, false)">Start without Modules</button>
        <button onclick="goBack()">Back</button>
    </div>
    <div id="victoryScreen">
        <h1 id="winnerText"></h1>
        <p>Press any key to return to menu</p>
        <button onclick="restartGame()">Restart</button>
    </div>

<script>
    // DOM elements
    let gameContainer, canvas, ctx, menu, botMenu, difficultyMenu, moduleMenu, victoryScreen, winnerText, uiPanel;

    // Game state and constants
    let victoryDisplayTime = 0;
    let playerCount = 0;
    let lastTime = performance.now();
    let botCount = 0;
    let gameState = 'menu';
    let eliminations = [];
    let frameCount = 0;
    let countdownStart = 0;
    let countdownValue = 3;
    let chaosTimer = 0;
    const MAX_PARTICLES = 2000;
    let MAX_SHIPS_PER_PLAYER = 100;
    const PLAYER_SPEED = { max: 1.5, min: -0.9, acceleration: 0.08, deceleration: 0.94 };
    const MIN_DISTANCE = 100;
    const ASTEROID_SPAWN_DISTANCE = 100;
    const sidebarWidth = 150;

    // Game objects
    const players = [];
    const menuBots = [];
    const asteroids = [];
    const obstacles = [];
    const particles = [];
    const powerUps = [];
    const stars = [];
    const gravityWells = [];
    const keys = {};
    const damageDisplays = [];
    let formationDisplays = [];
    const powerUpDisplays = [];
    let MAX_ASTEROIDS = 15;
    let botMessages = [];
    let selectedDifficulty = null;

    // Module settings
    let modules = {
        noAsteroids: false,
        doubleAsteroids: false,
        doubleHealth: false,
        oneShot: false,
        doublePowerUps: false,
        maxShips1000: false,
        chromebookMode: false,
        pixelMode: false,
        smallMode: false,
        threeLives: false,
        romansExpansion: false,
        gravityWells: false,
        stealthMode: false,
        chaosMode: false,
        infiniteArena: false,
        separation: false
    };

    // Load modules from localStorage
    function loadModules() {
        const savedModules = localStorage.getItem('gameModules');
        if (savedModules) modules = JSON.parse(savedModules);
    }
    loadModules();

    // New Tab toggle state
    let isNewTabMode = false;

    // Audio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(frequency, duration, type = 'sine', volume = 0.1) {
        const osc = audioCtx.createOscillator();
        osc.type = type;
        osc.frequency.value = frequency;
        const gain = audioCtx.createGain();
        gain.gain.value = volume;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.stop(audioCtx.currentTime + duration);
    }

    // Favicon and title handling
    function toggleNewTab() {
        isNewTabMode = !isNewTabMode;
        const faviconOptions = document.getElementById('faviconOptions');
        const toggleButton = document.getElementById('toggleNewTabButton');
        const favicon = document.getElementById('favicon');
        if (isNewTabMode) {
            document.title = 'New Tab';
            faviconOptions.style.display = 'flex';
            toggleButton.textContent = 'Toggle New Tab Off';
            setFavicon('light');
        } else {
            document.title = 'TopDownSpace';
            faviconOptions.style.display = 'none';
            toggleButton.textContent = 'Toggle New Tab On';
            favicon.href = 'https://topdownspace.github.io/favicon-32x32.png';
        }
    }

    function setFavicon(mode) {
        const favicon = document.getElementById('favicon');
        if (mode === 'light') favicon.href = 'chromenewtab32x32.png';
        else if (mode === 'dark') favicon.href = 'darkchromenewtab32x32.png';
    }

    // Bot speech
    const botSpeech = {
        aggressive: {
            lowHP: ["Shields critical!", "Taking heavy fire!", "Systems failing!"],
            chasing: ["Target locked!", "Engaging hostile!", "You’re mine!"],
            formation: ["Assault pattern alpha!", "Strike formation!", "Combat array!"],
            powerUp: ["Reinforcements acquired!", "Power surge!", "Fleet boosted!"],
            retreating: ["Falling back!", "Evasive maneuvers!", "Regrouping!"]
        },
        defensive: {
            lowHP: ["Hull breach!", "Shields down!", "Critical damage!"],
            chasing: ["Maintaining distance!", "Tracking target!", "Stay in range!"],
            formation: ["Defensive grid!", "Shield wall!", "Fortify positions!"],
            powerUp: ["Reserves online!", "Support incoming!", "Fleet stabilized!"],
            retreating: ["Withdrawing!", "Retreat protocol!", "Disengaging!"]
        },
        dashy: {
            lowHP: ["Engines failing!", "Speed compromised!", "Damage critical!"],
            chasing: ["Closing fast!", "High-speed pursuit!", "Target in sights!"],
            formation: ["Rapid deploy!", "Swift formation!", "Speed array!"],
            powerUp: ["Boost engaged!", "Velocity spiked!", "Fleet accelerated!"],
            retreating: ["Evasive dash!", "Full throttle retreat!", "Out of here!"]
        },
        formation: {
            lowHP: ["Structure collapsing!", "Fleet integrity low!", "Formation breaking!"],
            chasing: ["Tactical pursuit!", "Coordinated strike!", "Target enveloped!"],
            formation: ["Realigning fleet!", "Formation shift!", "Strategic pattern!"],
            powerUp: ["Squadron reinforced!", "Fleet expanded!", "Tactical boost!"],
            retreating: ["Regroup order!", "Formation retreat!", "Pulling back!"]
        }
    };

    // Button click animation
    function animateButtonClick(button) {
        const ship = {
            x: -20,
            y: button.offsetTop + button.offsetHeight / 2,
            angle: 0,
            speed: 5,
            color: '#ffcc00'
        };
        const targetX = button.offsetLeft + button.offsetWidth / 2;

        function animate() {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-6, 6);
            ctx.lineTo(-4, 0);
            ctx.lineTo(-6, -6);
            ctx.closePath();
            ctx.fillStyle = ship.color;
            ctx.fill();
            ctx.restore();

            ship.x += ship.speed;
            if (ship.x >= targetX) {
                button.classList.add('clicked');
                setTimeout(() => button.classList.remove('clicked'), 300);
                return;
            }
            requestAnimationFrame(animate);
        }
        animate();
    }

    document.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') animateButtonClick(e.target);
    });

    // Menu navigation
    function showBotMenu(players) {
        playerCount = players;
        menu.style.display = 'none';
        botMenu.style.display = 'flex';
    }

    function showDifficultyMenu(bots) {
        botCount = bots;
        botMenu.style.display = 'none';
        difficultyMenu.style.display = 'flex';
    }

    function showModuleMenu(difficulty) {
        selectedDifficulty = difficulty;
        difficultyMenu.style.display = 'none';
        moduleMenu.style.display = 'flex';
        const checklist = document.getElementById('moduleChecklist');
        checklist.innerHTML = '';
        const moduleOptions = [
            { id: 'noAsteroids', label: 'No Asteroids', desc: 'Removes all asteroids from the game.' },
            { id: 'doubleAsteroids', label: 'Double Asteroids', desc: 'Doubles the number of asteroids.' },
            { id: 'doubleHealth', label: 'Double Health', desc: 'Doubles each ship’s health.' },
            { id: 'oneShot', label: 'One Shot', desc: 'All ships have 1 HP.' },
            { id: 'doublePowerUps', label: 'Double Power-Ups', desc: 'Doubles power-up spawn rate.' },
            { id: 'maxShips1000', label: 'Max Ships 1000', desc: 'Sets max ships per player to 1000.' },
            { id: 'chromebookMode', label: 'Chromebook Mode', desc: 'Optimizes for slower devices.' },
            { id: 'pixelMode', label: 'Pixel Mode', desc: 'Pixelates the game for a retro look.' },
            { id: 'smallMode', label: 'Small Mode', desc: 'Shrinks everything for longer games.' },
            { id: 'threeLives', label: '3 Lives', desc: 'Players respawn up to 3 times.' },
            { id: 'romansExpansion', label: 'Roman\'s Expansion', desc: 'Replaces formations with powerful Roman shapes: Rectangle, Circle, Disguise, Trap, Trinity H/V.' },
            { id: 'gravityWells', label: 'Gravity Wells', desc: 'Adds 3 gravity wells pulling ships and bullets.' },
            { id: 'stealthMode', label: 'Stealth Mode', desc: 'Ships are invisible unless firing.' },
            { id: 'chaosMode', label: 'Chaos Mode', desc: 'Triggers random events every 30 seconds.' },
            { id: 'infiniteArena', label: 'Infinite Arena', desc: 'Wraps ships and bullets around screen edges.' },
            { id: 'separation', label: 'Separation', desc: 'Divides map into quarters; barriers fall as players are eliminated.' }
        ];
        moduleOptions.forEach(opt => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = opt.id;
            checkbox.checked = modules[opt.id];
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(opt.label));
            const tooltip = document.createElement('span');
            tooltip.className = 'tooltip';
            tooltip.textContent = opt.desc;
            label.appendChild(tooltip);
            checklist.appendChild(label);
        });
    }

    function goBack() {
        if (moduleMenu.style.display !== 'none') {
            moduleMenu.style.display = 'none';
            difficultyMenu.style.display = 'flex';
        } else if (difficultyMenu.style.display !== 'none') {
            difficultyMenu.style.display = 'none';
            botMenu.style.display = 'flex';
        } else if (botMenu.style.display !== 'none') {
            botMenu.style.display = 'none';
            menu.style.display = 'flex';
        }
    }

    function initMenuBots() {
        menuBots.length = 0;
        const positions = [];
        const getSafePosition = () => {
            let x, y;
            do {
                x = Math.random() * (canvas.width - 25) + 12.5;
                y = Math.random() * (canvas.height - 25) + 12.5;
            } while (positions.some(pos => Math.hypot(pos.x - x, pos.y - y) < MIN_DISTANCE));
            positions.push({ x, y });
            return { x, y };
        };

        const botStyles = ['aggressive', 'defensive', 'dashy', 'formation'];
        for (let i = 0; i < 8; i++) {
            const pos = getSafePosition();
            const style = botStyles[Math.floor(Math.random() * botStyles.length)];
            const traitColor = `#${Math.floor(Math.random() * 256).toString(16).padStart(2, '0')}${Math.floor(Math.random() * 256).toString(16).padStart(2, '0')}${Math.floor(Math.random() * 256).toString(16).padStart(2, '0')}`;
            menuBots.push({
                ships: [{ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000), dx: 0, dy: 0 }],
                keys: { up: '', down: '', left: '', right: '', form: '', dash: '' },
                bullets: [],
                alive: true,
                formation: 'spiral',
                lastShot: 0,
                lastDash: 0,
                dashEnd: 0,
                dashSpeed: 0,
                isBot: true,
                difficulty: 'standard',
                style: style,
                traitColor: traitColor,
                lastMessageTime: 0,
                botState: 'patrolling',
                target: null,
                lastDecision: 0
            });
        }
    }

    function startGame(bots, withModules) {
        botCount = bots;
        if (withModules) {
            Object.keys(modules).forEach(key => {
                const checkbox = document.getElementById(key);
                if (checkbox) modules[key] = checkbox.checked;
            });
            localStorage.setItem('gameModules', JSON.stringify(modules));
        }

        MAX_SHIPS_PER_PLAYER = modules.maxShips1000 ? 1000 : 100;
        MAX_ASTEROIDS = modules.noAsteroids ? 0 : (modules.doubleAsteroids ? 30 : 15);

        players.length = 0;
        menuBots.length = 0;
        asteroids.length = 0;
        obstacles.length = 0;
        particles.length = 0;
        powerUps.length = 0;
        gravityWells.length = 0;
        damageDisplays.length = 0;
        formationDisplays.length = 0;
        powerUpDisplays.length = 0;
        botMessages.length = 0;

        const positions = [];
        const getSafePosition = (quarter) => {
            let x, y;
            do {
                if (modules.separation) {
                    if (quarter === 0) { x = Math.random() * canvas.width / 2; y = Math.random() * canvas.height / 2; }
                    else if (quarter === 1) { x = canvas.width / 2 + Math.random() * canvas.width / 2; y = Math.random() * canvas.height / 2; }
                    else if (quarter === 2) { x = Math.random() * canvas.width / 2; y = canvas.height / 2 + Math.random() * canvas.height / 2; }
                    else { x = canvas.width / 2 + Math.random() * canvas.width / 2; y = canvas.height / 2 + Math.random() * canvas.height / 2; }
                } else {
                    x = Math.random() * (canvas.width - 25) + 12.5;
                    y = Math.random() * (canvas.height - 25) + 12.5;
                }
            } while (positions.some(pos => Math.hypot(pos.x - x, pos.y - y) < MIN_DISTANCE));
            positions.push({ x, y });
            return { x, y };
        };

        const defaultControls = [
            { up: 'w', down: 's', left: 'a', right: 'd', form: 'e', dash: 'q' },
            { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', form: 'Shift', dash: '/' },
            { up: 'i', down: 'k', left: 'j', right: 'l', form: 'o', dash: 'u' }
        ];
        for (let i = 0; i < playerCount; i++) {
            const pos = getSafePosition(i % 4);
            const traitColor = ['#ff3333', '#33ccff', '#33ff33'][i % 3];
            players.push({
                ships: [{ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000), dx: 0, dy: 0 }],
                keys: defaultControls[i % 3],
                bullets: [],
                alive: true,
                formation: modules.romansExpansion ? 'romansRectangle' : 'spiral',
                lastShot: 0,
                lastDash: 0,
                dashEnd: 0,
                dashSpeed: 0,
                isBot: false,
                difficulty: 'player',
                traitColor: traitColor,
                lastMessageTime: 0,
                lives: modules.threeLives ? 3 : 1,
                quarter: modules.separation ? i % 4 : null
            });
        }

        const botStyles = ['aggressive', 'defensive', 'dashy', 'formation'];
        for (let i = 0; i < botCount; i++) {
            const pos = getSafePosition(i % 4);
            const style = botStyles[Math.floor(Math.random() * botStyles.length)];
            const traitColor = `#${Math.floor(Math.random() * 256).toString(16).padStart(2, '0')}${Math.floor(Math.random() * 256).toString(16).padStart(2, '0')}${Math.floor(Math.random() * 256).toString(16).padStart(2, '0')}`;
            players.push({
                ships: [{ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000), dx: 0, dy: 0 }],
                keys: { up: '', down: '', left: '', right: '', form: '', dash: '' },
                bullets: [],
                alive: true,
                formation: modules.romansExpansion ? 'romansRectangle' : 'spiral',
                lastShot: 0,
                lastDash: 0,
                dashEnd: 0,
                dashSpeed: 0,
                isBot: true,
                difficulty: selectedDifficulty || 'standard',
                style: style,
                traitColor: traitColor,
                lastMessageTime: 0,
                botState: 'patrolling',
                target: null,
                lastDecision: 0,
                lives: modules.threeLives ? 3 : 1,
                quarter: modules.separation ? i % 4 : null
            });
        }

        gameState = 'countdown';
        countdownStart = Date.now();
        countdownValue = 3;
        menu.style.display = 'none';
        botMenu.style.display = 'none';
        difficultyMenu.style.display = 'none';
        moduleMenu.style.display = 'none';
        victoryScreen.style.display = 'none';
        uiPanel.style.display = 'block';
        spawnObstacles();
        spawnStars();
        spawnNebula();
        if (modules.gravityWells) spawnGravityWells();
        spawnAsteroids();
        frameCount = 0;
        chaosTimer = 0;
        if (modules.pixelMode) canvas.style.imageRendering = 'pixelated';
        else canvas.style.imageRendering = 'optimizeSpeed';
    }

    function restartGame() {
        gameState = 'menu';
        victoryScreen.style.display = 'none';
        menu.style.display = 'flex';
        uiPanel.style.display = 'none';
        eliminations = [];
        players.length = 0;
        asteroids.length = 0;
        obstacles.length = 0;
        particles.length = 0;
        powerUps.length = 0;
        gravityWells.length = 0;
        botMessages.length = 0;
        initMenuBots();
        frameCount = 0;
    }

    // Drawing and utility functions
    function drawShip(ship, totalEntities, isLead, isPlayer, player) {
        if (modules.stealthMode && Date.now() - player.lastShot > 2000) return;
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        const size = modules.smallMode ? Math.max(1, 6 - totalEntities * 0.01) : Math.max(2, 12 - totalEntities * 0.02);
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.6, size * 0.6);
        ctx.lineTo(-size * 0.4, 0);
        ctx.lineTo(-size * 0.6, -size * 0.6);
        ctx.closePath();
        ctx.fillStyle = player.traitColor;
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
        if (ship.speed > 0 && Math.random() > 0.5) {
            ctx.beginPath();
            ctx.moveTo(-size * 0.6, 0);
            ctx.lineTo(-size * 0.8, 0);
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        ctx.restore();

        if (isLead && isPlayer && !player.isBot) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(ship.x, ship.y - size - 5, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffcc';
            ctx.fill();
            ctx.restore();
        }
    }

    function showDamage(x, y, damage, color) {
        const offsetX = (Math.random() - 0.5) * 15;
        const offsetY = (Math.random() - 0.5) * 15;
        damageDisplays.push({ x: x + offsetX, y: y + offsetY - 5, damage, color, time: Date.now() });
    }

    function showFormation(x, y, formation, color) {
        formationDisplays = [{ x, y, formation, color, time: Date.now() }];
    }

    function showPowerUp(x, y, count, color) {
        powerUpDisplays.push({ x, y, text: `+${count} Units`, color, time: Date.now() });
    }

    function showBotMessage(player, type) {
        if (Date.now() - player.lastMessageTime < 1000 || !player.ships[0]) return;
        const messages = botSpeech[player.style][type];
        if (messages) {
            botMessages.push({
                x: player.ships[0].x,
                y: player.ships[0].y - 15,
                text: messages[Math.floor(Math.random() * messages.length)],
                life: 90,
                color: player.traitColor
            });
            player.lastMessageTime = Date.now();
        }
    }

    function drawDamageFormationPowerUp() {
        damageDisplays.forEach((d, i) => {
            if (Date.now() - d.time > 600) damageDisplays.splice(i, 1);
            else {
                ctx.fillStyle = d.color;
                ctx.font = modules.smallMode ? '6px Orbitron' : '8px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(`-${d.damage}`, d.x, d.y);
            }
        });
        formationDisplays.forEach((f, i) => {
            if (Date.now() - f.time > 2500) formationDisplays.splice(i, 1);
            else {
                ctx.fillStyle = f.color;
                ctx.font = modules.smallMode ? '8px Orbitron' : '10px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(f.formation, f.x, f.y - 10);
            }
        });
        powerUpDisplays.forEach((p, i) => {
            if (Date.now() - p.time > 2500) powerUpDisplays.splice(i, 1);
            else {
                ctx.fillStyle = p.color;
                ctx.font = modules.smallMode ? '8px Orbitron' : '10px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(p.text, p.x, p.y - 10);
            }
        });
        botMessages.forEach((m, i) => {
            if (m.life-- <= 0) botMessages.splice(i, 1);
            else {
                ctx.fillStyle = m.color;
                ctx.font = modules.smallMode ? '6px Orbitron' : '8px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(m.text, m.x, m.y);
            }
        });
    }

    function drawBullets(player) {
        player.bullets.forEach(b => {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
            ctx.fillStyle = player.traitColor;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        });
    }

    function getTotalHP(player) {
        return player.ships.reduce((sum, s) => sum + s.hp, 0);
    }

    function isLowHealth(player) {
        const totalHP = getTotalHP(player);
        const maxHP = player.ships.length * (modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000));
        return totalHP / maxHP < 0.35;
    }

    function findNearestEnemy(player) {
        let nearest = null;
        let minDist = Infinity;
        players.forEach(p => {
            if (p !== player && p.alive && p.ships.length > 0) {
                const dist = Math.hypot(p.ships[0].x - player.ships[0].x, p.ships[0].y - player.ships[0].y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = p;
                }
            }
        });
        return { player: nearest, distance: minDist };
    }

    function findNearestPowerUp(player) {
        let nearest = null;
        let minDist = Infinity;
        powerUps.forEach(pu => {
            const dist = Math.hypot(pu.x - player.ships[0].x, pu.y - player.ships[0].y);
            if (dist < minDist) {
                minDist = dist;
                nearest = pu;
            }
        });
        return { powerUp: nearest, distance: minDist };
    }

    function predictPosition(target, bulletSpeed) {
        if (!target || !target.ships || !target.ships[0]) return { x: canvas.width / 2, y: canvas.height / 2 };
        const timeToImpact = Math.hypot(target.ships[0].x - target.ships[0].dx, target.ships[0].y - target.ships[0].dy) / bulletSpeed;
        return {
            x: target.ships[0].x + target.ships[0].dx * timeToImpact,
            y: target.ships[0].y + target.ships[0].dy * timeToImpact
        };
    }

    // Player and Bot update logic
    function updatePlayer(player, index, isMenuBot = false, deltaTime) {
        if (!player.alive || !player.ships.length) return;
        if (!isMenuBot && gameState !== 'playing') return;
        const leadShip = player.ships[0];
        const { up, down, left, right, form, dash } = player.keys;

        if (!player.isBot) {
            if (keys[up]) leadShip.speed = Math.min(leadShip.speed + PLAYER_SPEED.acceleration, PLAYER_SPEED.max);
            else if (keys[down]) leadShip.speed = Math.max(leadShip.speed - PLAYER_SPEED.acceleration, PLAYER_SPEED.min);
            else if (Date.now() > player.dashEnd) leadShip.speed *= PLAYER_SPEED.deceleration;
            if (keys[left]) leadShip.angle -= 0.15 * deltaTime * 60;
            if (keys[right]) leadShip.angle += 0.15 * deltaTime * 60;
            if (keys[form]) {
                keys[form] = false;
                player.formation = getNextFormation(player.formation);
                showFormation(leadShip.x, leadShip.y, player.formation, '#fff');
            }
            if (keys[dash] && Date.now() - player.lastDash > 1800) {
                player.dashSpeed = leadShip.speed + 4.5;
                player.dashEnd = Date.now() + 250;
                player.lastDash = Date.now();
                playSound(1200, 0.25, 'triangle', 0.25);
            }
            if (Date.now() - player.lastShot > 120 * (1 + player.ships.length * 0.015)) {
                const bulletSpeed = 2.5;
                player.ships.forEach(ship => {
                    const shootAngle = ship.angle;
                    player.bullets.push({
                        x: ship.x + Math.cos(shootAngle) * 3,
                        y: ship.y + Math.sin(shootAngle) * 3,
                        dx: Math.cos(shootAngle) * bulletSpeed,
                        dy: Math.sin(shootAngle) * bulletSpeed,
                        color: player.traitColor,
                        size: modules.smallMode ? 1 : 2,
                        time: Date.now(),
                        shooter: player,
                        bounces: 0
                    });
                });
                player.lastShot = Date.now();
                playSound(800, 0.1, 'sine', 0.15);
            }
        } else {
            const difficultySettings = {
                'novice': { turnSpeed: 0.05, aimError: 0.2, reactionTime: 400, awarenessRange: 300, dashFreq: 0.1, shootFreq: 200 },
                'standard': { turnSpeed: 0.1, aimError: 0.1, reactionTime: 250, awarenessRange: 350, dashFreq: 0.2, shootFreq: 180 },
                'elite': { turnSpeed: 0.15, aimError: 0.05, reactionTime: 150, awarenessRange: 400, dashFreq: 0.3, shootFreq: 150 },
                'Deity': { turnSpeed: 0.3, aimError: 0.005, reactionTime: 30, awarenessRange: 600, dashFreq: 0.6, shootFreq: 80 }
            };
            const settings = difficultySettings[player.difficulty] || difficultySettings['standard'];
            const styleParams = {
                aggressive: { chaseRange: 450, retreatThreshold: 0.25, speedBoost: 1.8 },
                defensive: { chaseRange: 350, retreatThreshold: 0.45, speedBoost: 1.4 },
                dashy: { chaseRange: 500, retreatThreshold: 0.3, speedBoost: 2.0 },
                formation: { chaseRange: 400, retreatThreshold: 0.35, speedBoost: 1.6 }
            };
            const style = styleParams[player.style];

            if (Date.now() - player.lastDecision > settings.reactionTime) {
                const { player: nearestEnemy, distance: enemyDist } = findNearestEnemy(player);
                const { powerUp: nearestPowerUp, distance: powerUpDist } = findNearestPowerUp(player);
                const isThreatened = players.some(p => p !== player && p.bullets.some(b => Math.hypot(b.x - leadShip.x, b.y - leadShip.y) < 60));
                const lowHealth = isLowHealth(player);
                const highHealth = getTotalHP(player) / (player.ships.length * (modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000))) > 0.75;

                if (lowHealth) {
                    player.botState = 'retreating';
                    showBotMessage(player, 'retreating');
                } else if (isThreatened) {
                    player.botState = 'evading';
                    showBotMessage(player, 'retreating');
                } else if (nearestPowerUp && powerUpDist < settings.awarenessRange && player.ships.length < MAX_SHIPS_PER_PLAYER / 2) {
                    player.botState = 'powerUpChase';
                    player.target = nearestPowerUp;
                    showBotMessage(player, 'powerUp');
                } else if (nearestEnemy && enemyDist < style.chaseRange) {
                    player.botState = highHealth && player.difficulty === 'Deity' ? 'aggressiveChase' : 'chasing';
                    player.target = nearestEnemy;
                    showBotMessage(player, 'chasing');
                } else {
                    player.botState = 'patrolling';
                    player.target = null;
                    if (Math.random() < 0.3) showBotMessage(player, 'formation');
                }
                player.lastDecision = Date.now();
            }

            let targetX, targetY;
            if ((player.botState === 'chasing' || player.botState === 'aggressiveChase') && player.target && player.target.ships && player.target.ships.length > 0) {
                const predicted = predictPosition(player.target, 2.5);
                targetX = predicted.x;
                targetY = predicted.y;
            } else if (player.botState === 'powerUpChase' && player.target) {
                targetX = player.target.x;
                targetY = player.target.y;
            } else if (player.botState === 'retreating') {
                targetX = canvas.width / 2 + (Math.random() - 0.5) * 400;
                targetY = canvas.height / 2 + (Math.random() - 0.5) * 400;
            } else if (player.botState === 'evading') {
                const threat = players.find(p => p !== player && p.bullets.some(b => Math.hypot(b.x - leadShip.x, b.y - leadShip.y) < 60));
                if (threat && threat.ships && threat.ships.length > 0) {
                    const dx = leadShip.x - threat.ships[0].x;
                    const dy = leadShip.y - threat.ships[0].y;
                    targetX = leadShip.x + dx * 4;
                    targetY = leadShip.y + dy * 4;
                } else {
                    targetX = leadShip.x;
                    targetY = leadShip.y;
                }
            } else { // patrolling
                if (!player.target || Math.hypot(leadShip.x - player.target.x, leadShip.y - player.target.y) < 30) {
                    targetX = Math.random() * (canvas.width - 100) + 50;
                    targetY = Math.random() * (canvas.height - 100) + 50;
                } else {
                    targetX = player.target.x;
                    targetY = player.target.y;
                }
            }

            // Avoidance logic
            let avoidX = 0, avoidY = 0;
            const borderMargin = 50;
            const borderForce = 100;
            if (!modules.infiniteArena) {
                if (leadShip.x < borderMargin) avoidX += borderForce * (borderMargin - leadShip.x);
                if (leadShip.x > canvas.width - borderMargin) avoidX -= borderForce * (leadShip.x - (canvas.width - borderMargin));
                if (leadShip.y < borderMargin) avoidY += borderForce * (borderMargin - leadShip.y);
                if (leadShip.y > canvas.height - borderMargin) avoidY -= borderForce * (leadShip.y - (canvas.height - borderMargin));
            }

            asteroids.forEach(a => {
                const dist = Math.hypot(leadShip.x - a.x, leadShip.y - a.y);
                if (dist < a.size + 50) {
                    const dx = leadShip.x - a.x;
                    const dy = leadShip.y - a.y;
                    const force = (50 - dist) / 50;
                    avoidX += dx * force * 0.1;
                    avoidY += dy * force * 0.1;
                }
            });

            players.forEach(p => {
                if (p !== player && p.alive && p.ships.length > 0) {
                    const dist = Math.hypot(leadShip.x - p.ships[0].x, leadShip.y - p.ships[0].y);
                    if (dist < 50 && player.style !== 'formation') {
                        const dx = leadShip.x - p.ships[0].x;
                        const dy = leadShip.y - p.ships[0].y;
                        avoidX += dx * 0.05;
                        avoidY += dy * 0.05;
                    }
                }
            });

            targetX += avoidX;
            targetY += avoidY;
            targetX = Math.max(50, Math.min(canvas.width - 50, targetX));
            targetY = Math.max(50, Math.min(canvas.height - 50, targetY));

            const desiredAngle = Math.atan2(targetY - leadShip.y, targetX - leadShip.x);
            const angleDiff = (desiredAngle - leadShip.angle + Math.PI) % (2 * Math.PI) - Math.PI;
            leadShip.angle += Math.max(-settings.turnSpeed, Math.min(settings.turnSpeed, angleDiff)) * deltaTime * 60;
            leadShip.speed = Math.min(leadShip.speed + PLAYER_SPEED.acceleration, PLAYER_SPEED.max * style.speedBoost);

            if (player.style === 'dashy' && Math.random() < settings.dashFreq && Date.now() - player.lastDash > 1800) {
                player.dashSpeed = leadShip.speed + 4.5;
                player.dashEnd = Date.now() + 250;
                player.lastDash = Date.now();
                playSound(1200, 0.25, 'triangle', 0.25);
            }

            if (Date.now() - player.lastShot > settings.shootFreq) {
                const distToTarget = player.target && (player.botState === 'chasing' || player.botState === 'aggressiveChase' ? player.target.ships.length > 0 : true) ? Math.hypot(targetX - leadShip.x, targetY - leadShip.y) : Infinity;
                if ((player.botState === 'chasing' && distToTarget < settings.awarenessRange) || 
                    (player.botState === 'aggressiveChase' && distToTarget < settings.awarenessRange * 1.5) ||
                    (player.botState === 'evading' && distToTarget < 150) ||
                    (player.botState === 'retreating' && Math.random() < 0.5) ||
                    (player.botState === 'patrolling' && Math.random() < 0.2)) {
                    if (Math.abs(angleDiff) < (player.difficulty === 'Deity' ? 0.3 : 0.7)) {
                        const bulletSpeed = player.difficulty === 'Deity' ? 3.5 : 2.5;
                        const shootAngle = leadShip.angle + (Math.random() - 0.5) * settings.aimError;
                        player.ships.forEach(ship => {
                            player.bullets.push({
                                x: ship.x + Math.cos(shootAngle) * 3,
                                y: ship.y + Math.sin(shootAngle) * 3,
                                dx: Math.cos(shootAngle) * bulletSpeed,
                                dy: Math.sin(shootAngle) * bulletSpeed,
                                color: player.traitColor,
                                size: modules.smallMode ? 1 : 2,
                                time: Date.now(),
                                shooter: player,
                                bounces: 0
                            });
                        });
                        player.lastShot = Date.now();
                        playSound(800, 0.1, 'sine', 0.15);
                        if (Math.random() < 0.5) showBotMessage(player, 'chasing');
                    }
                }
            }
        }

        if (Date.now() <= player.dashEnd) {
            leadShip.speed = player.dashSpeed;
            particles.push({
                x: leadShip.x - Math.cos(leadShip.angle) * 3,
                y: leadShip.y - Math.sin(leadShip.angle) * 3,
                size: modules.smallMode ? 0.5 : 1,
                life: 25,
                color: '#ffcc00',
                dx: -Math.cos(leadShip.angle) * 0.6,
                dy: -Math.sin(leadShip.angle) * 0.6
            });
        } else if (player.dashSpeed > 0) {
            player.dashSpeed *= 0.94;
            leadShip.speed = Math.max(leadShip.speed * 0.94, player.dashSpeed);
            if (player.dashSpeed < 0.05) player.dashSpeed = 0;
        }

        player.ships.forEach((ship, i) => {
            let targetX, targetY, offsetX, offsetY;
            if (i === 0) {
                ship.dx = Math.cos(ship.angle) * ship.speed * 1.8 * deltaTime * 60;
                ship.dy = Math.sin(ship.angle) * ship.speed * 1.8 * deltaTime * 60;
            } else {
                const formations = modules.romansExpansion ? {
                    'romansRectangle': () => {
                        const perimeter = player.ships.length * 6;
                        const width = Math.ceil(Math.sqrt(perimeter / 2));
                        const height = Math.ceil(perimeter / (2 * width));
                        const side = Math.floor(i / (player.ships.length / 4));
                        const pos = i % (player.ships.length / 4);
                        if (side === 0) { offsetX = pos * 6 - width * 3; offsetY = -height * 3; ship.angle = Math.PI / 2; }
                        else if (side === 1) { offsetX = width * 3; offsetY = pos * 6 - height * 3; ship.angle = 0; }
                        else if (side === 2) { offsetX = pos * 6 - width * 3; offsetY = height * 3; ship.angle = -Math.PI / 2; }
                        else { offsetX = -width * 3; offsetY = pos * 6 - height * 3; ship.angle = Math.PI; }
                    },
                    'romansCircle': () => {
                        const angle = (i / player.ships.length) * Math.PI * 2;
                        offsetX = Math.cos(angle) * 12;
                        offsetY = Math.sin(angle) * 12;
                        ship.angle = angle + Math.PI / 2;
                    },
                    'romansDisguise': () => { offsetX = 0; offsetY = 0; ship.angle = leadShip.angle; },
                    'romansTrap': () => {
                        const angle = (i / player.ships.length) * Math.PI * 2;
                        offsetX = Math.cos(angle) * 12;
                        offsetY = Math.sin(angle) * 12;
                        ship.angle = angle - Math.PI / 2;
                    },
                    'romansTrinityH': () => {
                        const third = Math.floor(player.ships.length / 3);
                        const line = Math.floor(i / third);
                        offsetX = (i % third - third / 2) * 6;
                        offsetY = (line - 1) * 12;
                        ship.angle = -Math.PI / 2;
                    },
                    'romansTrinityV': () => {
                        const third = Math.floor(player.ships.length / 3);
                        const line = Math.floor(i / third);
                        offsetX = (line - 1) * 12;
                        offsetY = (i % third - third / 2) * 6;
                        ship.angle = -Math.PI / 2;
                    }
                } : {
                    'diamond': () => { offsetX = (i % 2 === 0 ? 1 : -1) * Math.ceil(i / 2) * 3; offsetY = i * 3; },
                    'compact': () => { const angle = (i / Math.min(player.ships.length, MAX_SHIPS_PER_PLAYER)) * Math.PI * 2; offsetX = Math.cos(angle) * 4; offsetY = Math.sin(angle) * 4; },
                    'swarm': () => { const angle = (i / Math.min(player.ships.length, MAX_SHIPS_PER_PLAYER)) * Math.PI * 2; offsetX = Math.cos(angle) * 9; offsetY = Math.sin(angle) * 9; },
                    'line-h': () => { const half = Math.floor(player.ships.length / 2); offsetX = (i - half) * 6; offsetY = 0; },
                    'line-v': () => { const half = Math.floor(player.ships.length / 2); offsetX = 0; offsetY = (i - half) * 6; },
                    'spiral': () => { const radius = Math.min(12, i * 1.2); const angle = i * 0.9; offsetX = Math.cos(angle) * radius; offsetY = Math.sin(angle) * radius; }
                };
                formations[player.formation]();
                const noiseX = (Math.random() - 0.5) * 2.5;
                const noiseY = (Math.random() - 0.5) * 2.5;
                targetX = leadShip.x - Math.cos(leadShip.angle) * (offsetY + noiseY) - Math.sin(leadShip.angle) * (offsetX + noiseX);
                targetY = leadShip.y - Math.sin(leadShip.angle) * (offsetY + noiseY) + Math.cos(leadShip.angle) * (offsetX + noiseX);
                ship.dx = (targetX - ship.x) * 0.25 * 1.8 * deltaTime * 60;
                ship.dy = (targetY - ship.y) * 0.25 * 1.8 * deltaTime * 60;
                if (!modules.romansExpansion || player.formation === 'romansDisguise') ship.angle = leadShip.angle;
            }

            if (modules.gravityWells) {
                gravityWells.forEach(w => {
                    const dist = Math.hypot(ship.x - w.x, ship.y - w.y);
                    if (dist > 20) {
                        const force = 100 / (dist * dist);
                        ship.dx += (w.x - ship.x) * force * deltaTime * 60;
                        ship.dy += (w.y - ship.y) * force * deltaTime * 60;
                    }
                });
            }

            ship.dx *= Math.pow(0.97, deltaTime * 60);
            ship.dy *= Math.pow(0.97, deltaTime * 60);
            ship.x += ship.dx;
            ship.y += ship.dy;

            if (modules.infiniteArena) {
                ship.x = (ship.x + canvas.width) % canvas.width;
                ship.y = (ship.y + canvas.height) % canvas.height;
            } else {
                ship.x = Math.max(2, Math.min(canvas.width - 2, ship.x));
                ship.y = Math.max(2, Math.min(canvas.height - 2, ship.y));
            }

            if (modules.separation) {
                const aliveInQuarter = players.filter(p => p.alive && p.ships.length > 0 && p.quarter === player.quarter).length;
                const midX = canvas.width / 2;
                const midY = canvas.height / 2;
                if (aliveInQuarter > 1) {
                    if (player.quarter === 0) { ship.x = Math.min(midX, ship.x); ship.y = Math.min(midY, ship.y); }
                    else if (player.quarter === 1) { ship.x = Math.max(midX, ship.x); ship.y = Math.min(midY, ship.y); }
                    else if (player.quarter === 2) { ship.x = Math.min(midX, ship.x); ship.y = Math.max(midY, ship.y); }
                    else { ship.x = Math.max(midX, ship.x); ship.y = Math.max(midY, ship.y); }
                } else if (aliveInQuarter === 1) {
                    if (player.quarter % 2 === 0) ship.x = Math.min(midX, ship.x);
                    else ship.x = Math.max(midX, ship.x);
                }
            }

            if (!modules.chromebookMode || Math.random() < 0.5) {
                particles.push({ x: ship.x - Math.cos(ship.angle) * 1.5, y: ship.y - Math.sin(ship.angle) * 1.5, size: modules.smallMode ? 0.1 : 0.2, life: 10, color: player.traitColor });
            }
        });

        player.bullets.forEach(b => {
            if (modules.gravityWells) {
                gravityWells.forEach(w => {
                    const dist = Math.hypot(b.x - w.x, b.y - w.y);
                    if (dist > 10) {
                        const force = 50 / (dist * dist);
                        b.dx += (w.x - b.x) * force * deltaTime * 60;
                        b.dy += (w.y - b.y) * force * deltaTime * 60;
                    }
                });
            }
            b.x += b.dx * 1.8 * deltaTime * 60;
            b.y += b.dy * 1.8 * deltaTime * 60;

            if (modules.infiniteArena) {
                b.x = (b.x + canvas.width) % canvas.width;
                b.y = (b.y + canvas.height) % canvas.height;
            }

            if (!modules.chromebookMode || Math.random() < 0.5) {
                particles.push({ x: b.x - b.dx, y: b.y - b.dy, size: modules.smallMode ? 0.1 : 0.2, life: 6, color: b.color });
            }
        });
        player.bullets = player.bullets.filter(b => {
            const outOfBounds = !modules.infiniteArena && (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height);
            const expired = Date.now() - b.time > 1800;
            return !outOfBounds && !expired && b.bounces < 2;
        });
    }

    function getNextFormation(current) {
        const standardFormations = ['diamond', 'compact', 'swarm', 'line-h', 'line-v', 'spiral'];
        const romanFormations = ['romansRectangle', 'romansCircle', 'romansDisguise', 'romansTrap', 'romansTrinityH', 'romansTrinityV'];
        const formations = modules.romansExpansion ? romanFormations : standardFormations;
        const index = formations.indexOf(current);
        return formations[(index + 1) % formations.length];
    }

    // Game object spawning and updating
    function spawnAsteroids() {
        while (asteroids.length < MAX_ASTEROIDS) {
            let x, y;
            let tooClose;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
                tooClose = players.some(p => p.ships.some(s => Math.hypot(s.x - x, s.y - y) < ASTEROID_SPAWN_DISTANCE));
            } while (tooClose);
            asteroids.push({
                x, y,
                size: modules.smallMode ? 4 + Math.random() * 6 : 8 + Math.random() * 12,
                dx: (Math.random() - 0.5) * 1.2,
                dy: (Math.random() - 0.5) * 1.2,
                angle: 0,
                spin: (Math.random() - 0.5) * 0.025,
                hp: 1200
            });
        }
    }

    function updateAsteroids(deltaTime) {
        asteroids.forEach(a => {
            if (gameState === 'playing') {
                a.x += a.dx * deltaTime * 60;
                a.y += a.dy * deltaTime * 60;
                a.dx = Math.max(-1.8, Math.min(1.8, a.dx));
                a.dy = Math.max(-1.8, Math.min(1.8, a.dy));
                if (modules.infiniteArena) {
                    a.x = (a.x + canvas.width) % canvas.width;
                    a.y = (a.y + canvas.height) % canvas.height;
                } else {
                    if (a.x - a.size < 0 || a.x + a.size > canvas.width) a.dx *= -1;
                    if (a.y - a.size < 0 || a.y + a.size > canvas.height) a.dy *= -1;
                }

                obstacles.forEach(o => {
                    if (a.x + a.size > o.x && a.x - a.size < o.x + o.w &&
                        a.y + a.size > o.y && a.y - a.size < o.y + o.h) {
                        const dx = a.x - (o.x + o.w / 2);
                        const dy = a.y - (o.y + o.h / 2);
                        if (Math.abs(dx) > Math.abs(dy)) a.dx *= -1;
                        else a.dy *= -1;
                    }
                });
            }
            a.angle += a.spin * deltaTime * 60;
            ctx.fillStyle = '#4d4d4d';
            ctx.beginPath();
            for (let j = 0; j < 12; j++) {
                const angle = a.angle + (Math.PI * 2 * j) / 12;
                const r = a.size * (0.85 + Math.random() * 0.25);
                ctx[j === 0 ? 'moveTo' : 'lineTo'](a.x + Math.cos(angle) * r, a.y + Math.sin(angle) * r);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    function spawnObstacles() {
        for (let i = 0; i < 3; i++) {
            let x, y;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            } while (players.some(p => p.ships.some(s => Math.hypot(s.x - x, s.y - y) < 30)));
            obstacles.push({
                x, y,
                w: modules.smallMode ? 7.5 + Math.random() * 7.5 : 15 + Math.random() * 15,
                h: modules.smallMode ? 7.5 + Math.random() * 7.5 : 15 + Math.random() * 15,
                hp: 1500
            });
        }
    }

    function drawObstacles() {
        obstacles.forEach(o => {
            ctx.fillStyle = '#333366';
            ctx.fillRect(o.x, o.y, o.w, o.h);
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 1;
            ctx.strokeRect(o.x, o.y, o.w, o.h);
        });
    }

    function spawnStars() {
        for (let i = 0; i < (modules.chromebookMode ? 250 : 500); i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: modules.smallMode ? Math.random() * 0.25 + 0.05 : Math.random() * 0.5 + 0.1,
                brightness: Math.random()
            });
        }
    }

    function drawStars() {
        stars.forEach(s => {
            ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    const nebula = [];
    function spawnNebula() {
        for (let i = 0; i < (modules.chromebookMode ? 12 : 25); i++) {
            nebula.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: modules.smallMode ? 10 + Math.random() * 20 : 20 + Math.random() * 40,
                color: `rgba(${Math.random() * 100 + 50}, ${Math.random() * 100 + 50}, ${Math.random() * 200 + 50}, 0.15)`
            });
        }
    }

    function drawNebula() {
        nebula.forEach(n => {
            const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size);
            gradient.addColorStop(0, n.color);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function spawnGravityWells() {
        for (let i = 0; i < 3; i++) {
            gravityWells.push({
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                strength: 100
            });
        }
    }

    function drawGravityWells() {
        gravityWells.forEach(w => {
            const gradient = ctx.createRadialGradient(w.x, w.y, 0, w.x, w.y, 50);
            gradient.addColorStop(0, 'rgba(255, 0, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(w.x, w.y, 50, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function updateParticles(deltaTime) {
        if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
        particles.forEach((p, i) => {
            p.life -= deltaTime * 60;
            if (p.dx) p.x += p.dx * deltaTime * 60;
            if (p.dy) p.y += p.dy * deltaTime * 60;
            p.dx = p.dx ? p.dx * Math.pow(0.94, deltaTime * 60) : 0;
            p.dy = p.dy ? p.dy * Math.pow(0.94, deltaTime * 60) : 0;
            if (modules.infiniteArena) {
                p.x = (p.x + canvas.width) % canvas.width;
                p.y = (p.y + canvas.height) % canvas.height;
            }
            if (p.life <= 0) particles.splice(i, 1);
            else {
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.life / 50})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    function spawnPowerUps() {
        const totalPlayers = players.filter(p => p.alive).length;
        const baseProbability = modules.doublePowerUps ? 0.024 : 0.012;
        const spawnProbability = baseProbability * (1 + (totalPlayers - 1) * 0.15);
        if (Math.random() < spawnProbability) {
            const roll = Math.random();
            const type = roll < 0.2 ? '+2' : roll < 0.4 ? '+4' : roll < 0.6 ? '+6' : roll < 0.8 ? '+8' : '+10';
            powerUps.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                type,
                pulse: 0,
                pulseDirection: 1
            });
        }
    }

    function updatePowerUps() {
        powerUps.forEach((pu, i) => {
            pu.pulse += pu.pulseDirection * 0.12;
            if (pu.pulse >= 1) pu.pulseDirection = -1;
            if (pu.pulse <= 0) pu.pulseDirection = 1;
            const radius = (modules.smallMode ? 6 : 12) + pu.pulse * 4;

            ctx.fillStyle = 'rgba(0, 255, 204, 0.3)';
            ctx.beginPath();
            ctx.arc(pu.x, pu.y, radius + 6, 0, Math.PI * 2);
            ctx.fill();

            const gradient = ctx.createRadialGradient(pu.x, pu.y, 0, pu.x, pu.y, radius);
            gradient.addColorStop(0, '#00ffcc');
            gradient.addColorStop(1, '#0066ff');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pu.x, pu.y, radius, 0, Math.PI * 2);
            ctx.fill();

            if ((!modules.chromebookMode || Math.random() < 0.5) && Math.random() < 0.4) {
                particles.push({
                    x: pu.x + (Math.random() - 0.5) * radius * 2,
                    y: pu.y + (Math.random() - 0.5) * radius * 2,
                    size: modules.smallMode ? 0.6 : 1.2,
                    life: 25,
                    color: '#00ffcc',
                    dx: (Math.random() - 0.5) * 1.2,
                    dy: (Math.random() - 0.5) * 1.2
                });
            }

            ctx.fillStyle = '#ffffff';
            ctx.font = modules.smallMode ? '8px Orbitron' : '10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(pu.type, pu.x, pu.y + 3);

players.forEach(p => {
    p.ships.forEach(s => {
        if (Math.hypot(s.x - pu.x, s.y - pu.y) < radius + 6 && p.ships.length < MAX_SHIPS_PER_PLAYER) {
            const count = Math.min(parseInt(pu.type.slice(1)), MAX_SHIPS_PER_PLAYER - p.ships.length);
            for (let j = 0; j < count; j++) {
                p.ships.push({ x: s.x, y: s.y, angle: s.angle, speed: 0, hp: modules.oneShot ? 1 : (modules.doubleHealth ? 600 : 300), dx: 0, dy: 0 });
            }
            showPowerUp(pu.x, pu.y, count, '#00ffcc');
            if (p.isBot) showBotMessage(p, 'powerUp');
            powerUps.splice(i, 1);
            playSound(700 + count * 50, 0.35, 'triangle', 0.25); // Higher pitch for more ships
        }
    });
});
        });
    }

    function explosion(x, y, count, baseColor = '#ffcc00', size = 1.5, isFinal = false) {
        const colors = ['#ffffff', '#ffffcc', '#ffcc00'];
        for (let i = 0; i < Math.min(count * 1.5, MAX_PARTICLES - particles.length); i++) {
            const color = colors[Math.floor(Math.random() * colors.length)];
            const particleSize = (modules.smallMode ? size / 2 : size) + Math.random() * 0.5;
            particles.push({
                x, y,
                size: particleSize,
                life: 20,
                color,
                dx: (Math.random() - 0.5) * 10,
                dy: (Math.random() - 0.5) * 10
            });
        }
        if (isFinal) {
            for (let i = 0; i < Math.min(count, MAX_PARTICLES - particles.length); i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                particles.push({
                    x, y,
                    size: (modules.smallMode ? 0.5 : 1) + Math.random() * 0.5,
                    life: 25,
                    color,
                    dx: (Math.random() - 0.5) * 12,
                    dy: (Math.random() - 0.5) * 12
                });
            }
            playSound(80, 0.8, 'sawtooth', 0.3); // Deep, resonant boom
            playSound(200, 0.6, 'sine', 0.2); // Secondary high-pitched burst
        } else {
            playSound(100 + count * 5, 0.5, 'square', 0.25); // Varied pitch based on size
        }
    }

    function triggerChaosEvent() {
        const events = [
            () => { // Asteroid Shower
                for (let i = 0; i < 10; i++) {
                    asteroids.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: modules.smallMode ? 4 + Math.random() * 4 : 8 + Math.random() * 8,
                        dx: (Math.random() - 0.5) * 2,
                        dy: (Math.random() - 0.5) * 2,
                        angle: 0,
                        spin: (Math.random() - 0.5) * 0.03,
                        hp: 800
                    });
                }
                playSound(150, 1.0, 'sawtooth', 0.3); // Rumbling sound
            },
            () => { // Power-Up Storm
                for (let i = 0; i < 5; i++) {
                    powerUps.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        type: `+${Math.floor(Math.random() * 5) * 2 + 2}`,
                        pulse: 0,
                        pulseDirection: 1
                    });
                }
                playSound(600, 0.5, 'triangle', 0.25); // Sparkling chime
            },
            () => { // Gravity Shift
                gravityWells.forEach(w => {
                    w.x = Math.random() * (canvas.width - 100) + 50;
                    w.y = Math.random() * (canvas.height - 100) + 50;
                });
                playSound(300, 0.7, 'sine', 0.2); // Warping sound
            }
        ];
        const event = events[Math.floor(Math.random() * events.length)];
        event();
    }

    // Collision detection with bullet bounce and 3 lives
    function checkCollisions() {
        players.forEach(p => {
            if (!p.ships.length) {
                p.bullets = [];
                return;
            }
            for (let bi = p.bullets.length - 1; bi >= 0; bi--) {
                const b = p.bullets[bi];
                players.forEach(targetPlayer => {
                    if (targetPlayer !== p && targetPlayer.alive) {
                        for (let si = targetPlayer.ships.length - 1; si >= 0; si--) {
                            const s = targetPlayer.ships[si];
                            const dist = Math.hypot(s.x - b.x, s.y - b.y);
                            if (dist < 8) {
                                s.hp -= 40;
                                s.dx -= b.dx * 0.06;
                                s.dy -= b.dy * 0.06;
                                showDamage(s.x, s.y, 40, targetPlayer.traitColor);
                                explosion(b.x, b.y, 6, targetPlayer.traitColor);
                                if (s.hp <= 0) {
                                    targetPlayer.ships.splice(si, 1);
                                    explosion(s.x, s.y, 50, targetPlayer.traitColor);
                                }
                                p.bullets.splice(bi, 1);
                                playSound(500, 0.15, 'square', 0.2); // Sharp hit sound
                                return;
                            }
                        }
                    }
                });

                if (p.bullets[bi]) {
                    asteroids.forEach((a, ai) => {
                        const dist = Math.hypot(a.x - b.x, a.y - b.y);
                        if (dist < a.size) {
                            a.hp -= 40;
                            showDamage(a.x, a.y, 40, '#fff');
                            explosion(b.x, b.y, 6, '#999999');
                            if (a.hp <= 0) {
                                asteroids.splice(ai, 1);
                                explosion(a.x, a.y, 50, '#999999');
                                if (a.size > 6) {
                                    for (let i = 0; i < 2; i++) {
                                        asteroids.push({
                                            x: a.x + (Math.random() - 0.5) * a.size,
                                            y: a.y + (Math.random() - 0.5) * a.size,
                                            size: a.size / 2,
                                            dx: (Math.random() - 0.5) * 1.8,
                                            dy: (Math.random() - 0.5) * 1.8,
                                            angle: 0,
                                            spin: (Math.random() - 0.5) * 0.025,
                                            hp: 600
                                        });
                                    }
                                }
                            }
                            p.bullets.splice(bi, 1);
                            playSound(400, 0.2, 'sawtooth', 0.25); // Rock-breaking crunch
                            return;
                        }
                    });
                }

                if (p.bullets[bi]) {
                    obstacles.forEach(o => {
                        if (b.x + b.size > o.x && b.x - b.size < o.x + o.w &&
                            b.y + b.size > o.y && b.y - b.size < o.y + o.h && b.bounces < 2) {
                            const overlapX = Math.min(b.x + b.size - o.x, o.x + o.w - (b.x - b.size));
                            const overlapY = Math.min(b.y + b.size - o.y, o.y + o.h - (b.y - b.size));
                            if (overlapX < overlapY) {
                                b.dx *= -1;
                                b.x += b.dx > 0 ? overlapX : -overlapX;
                            } else {
                                b.dy *= -1;
                                b.y += b.dy > 0 ? overlapY : -overlapY;
                            }
                            b.bounces++;
                            playSound(300 + Math.random() * 100, 0.1, 'square', 0.2); // Randomized ricochet
                        }
                    });
                }
            }
        });

        for (let pi = 0; pi < players.length; pi++) {
            const p = players[pi];
            if (!p.ships.length) continue;

            for (let si = p.ships.length - 1; si >= 0; si--) {
                const s = p.ships[si];
                for (let opi = 0; opi < players.length; opi++) {
                    if (opi === pi) continue;
                    const op = players[opi];
                    if (!op.alive) continue;

                    for (let osi = op.ships.length - 1; osi >= 0; osi--) {
                        const os = op.ships[osi];
                        const dist = Math.hypot(s.x - os.x, s.y - os.y);
                        const shipSize = modules.smallMode ? Math.max(1, 6 - p.ships.length * 0.01) : Math.max(2, 12 - p.ships.length * 0.02);
                        if (dist < shipSize) {
                            const damage = Math.max(12, Math.floor((Math.sqrt(s.dx * s.dx + s.dy * s.dy) + Math.sqrt(os.dx * os.dx + os.dy * os.dy)) * 5));
                            s.hp -= damage;
                            os.hp -= damage;
                            showDamage(s.x, s.y, damage, p.traitColor);
                            showDamage(os.x, os.y, damage, op.traitColor);
                            explosion(s.x, s.y, 12, p.traitColor);

                            const dx = s.x - os.x;
                            const dy = s.y - os.y;
                            const distActual = Math.hypot(dx, dy) || 1;
                            const pushForce = 0.12;
                            s.dx += (dx / distActual) * pushForce;
                            s.dy += (dy / distActual) * pushForce;
                            os.dx -= (dx / distActual) * pushForce;
                            os.dy -= (dy / distActual) * pushForce;

                            if (s.hp <= 0) {
                                p.ships.splice(si, 1);
                                explosion(s.x, s.y, 50, p.traitColor);
                            }
                            if (os.hp <= 0) {
                                op.ships.splice(osi, 1);
                                explosion(os.x, os.y, 50, op.traitColor);
                            }
                            playSound(120 + Math.random() * 60, 0.6, 'sine', 0.3); // Varied collision thud
                            break;
                        }
                    }
                }
            }
        }

        asteroids.forEach((a, ai) => {
            players.forEach(p => {
                if (!p.ships.length || !p.alive) return;
                for (let si = p.ships.length - 1; si >= 0; si--) {
                    const s = p.ships[si];
                    const dist = Math.hypot(a.x - s.x, a.y - s.y);
                    const shipSize = modules.smallMode ? Math.max(1, 6 - p.ships.length * 0.01) : Math.max(2, 12 - p.ships.length * 0.02);
                    if (dist < a.size + shipSize) {
                        const damage = 12;
                        s.hp -= damage;
                        a.hp -= damage;
                        showDamage(s.x, s.y, damage, p.traitColor);
                        showDamage(a.x, a.y, damage, '#fff');
                        explosion(s.x, s.y, 18, p.traitColor);

                        const dx = s.x - a.x;
                        const dy = s.y - a.y;
                        const distActual = Math.hypot(dx, dy) || 1;
                        const pushForce = 0.18;
                        s.dx += (dx / distActual) * pushForce;
                        s.dy += (dy / distActual) * pushForce;

                        if (s.hp <= 0) {
                            p.ships.splice(si, 1);
                            explosion(s.x, s.y, 50, p.traitColor);
                        }
                        if (a.hp <= 0) {
                            asteroids.splice(ai, 1);
                            explosion(a.x, a.y, 50, '#999999');
                            if (a.size > 6) {
                                for (let i = 0; i < 2; i++) {
                                    asteroids.push({
                                        x: a.x + (Math.random() - 0.5) * a.size,
                                        y: a.y + (Math.random() - 0.5) * a.size,
                                        size: a.size / 2,
                                        dx: (Math.random() - 0.5) * 1.8,
                                        dy: (Math.random() - 0.5) * 1.8,
                                        angle: 0,
                                        spin: (Math.random() - 0.5) * 0.025,
                                        hp: 600
                                    });
                                }
                            }
                        }
                        playSound(140 + Math.random() * 50, 0.6, 'sawtooth', 0.3); // Crunchy asteroid hit
                        break;
                    }
                }
            });
        });

        obstacles.forEach(o => {
            players.forEach(p => {
                if (!p.ships.length || !p.alive) return;
                for (let si = p.ships.length - 1; si >= 0; si--) {
                    const s = p.ships[si];
                    const shipSize = modules.smallMode ? Math.max(1, 6 - p.ships.length * 0.01) : Math.max(2, 12 - p.ships.length * 0.02);
                    const shipLeft = s.x - shipSize;
                    const shipRight = s.x + shipSize;
                    const shipTop = s.y - shipSize;
                    const shipBottom = s.y + shipSize;
                    const obsLeft = o.x;
                    const obsRight = o.x + o.w;
                    const obsTop = o.y;
                    const obsBottom = o.y + o.h;

                    if (shipRight > obsLeft && shipLeft < obsRight && shipBottom > obsTop && shipTop < obsBottom) {
                        const overlapX = Math.min(shipRight - obsLeft, obsRight - shipLeft);
                        const overlapY = Math.min(shipBottom - obsTop, obsBottom - shipTop);
                        if (overlapX < overlapY) {
                            if (s.x < o.x + o.w / 2) {
                                s.x -= overlapX;
                                s.dx = 0;
                            } else {
                                s.x += overlapX;
                                s.dx = 0;
                            }
                        } else {
                            if (s.y < o.y + o.h / 2) {
                                s.y -= overlapY;
                                s.dy = 0;
                            } else {
                                s.y += overlapY;
                                s.dy = 0;
                            }
                        }
                        playSound(200 + Math.random() * 80, 0.3, 'square', 0.25); // Solid impact sound
                    }
                }
            });
        });

        players.forEach(p => {
            if (!p.ships.length && p.alive) {
                p.lives--;
                if (p.lives > 0 && modules.threeLives) {
                    const pos = { x: Math.random() * (canvas.width - 25) + 12.5, y: Math.random() * (canvas.height - 25) + 12.5 };
                    p.ships.push({ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000), dx: 0, dy: 0 });
                    playSound(1000, 0.4, 'triangle', 0.2); // Respawn chime
                } else {
                    p.alive = false;
                    p.bullets = [];
                    eliminations.push({ name: p.isBot ? `AI ${players.indexOf(p) + 1}` : `Pilot ${players.indexOf(p) + 1}`, time: Date.now() });
                    explosion(p.ships[0]?.x || canvas.width / 2, p.ships[0]?.y || canvas.height / 2, 200, p.traitColor, 1.5, true);
                }
            }
        });
    }

    // Main game loop
    function gameLoop(currentTime) {
        const deltaTime = Math.min(0.1, (currentTime - lastTime) / 1000);
        lastTime = currentTime;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        frameCount++;

        drawNebula();
        drawStars();
        drawObstacles();
        if (modules.gravityWells) drawGravityWells();

        if (gameState === 'menu') {
            menuBots.forEach((bot, i) => updatePlayer(bot, i, true, deltaTime));
            checkCollisions();
            menuBots.forEach((bot, i) => {
                if (!bot.ships.length) {
                    const pos = { x: Math.random() * (canvas.width - 25) + 12.5, y: Math.random() * (canvas.height - 25) + 12.5 };
                    bot.ships.push({ x: pos.x, y: pos.y, angle: 0, speed: 0, hp: modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000), dx: 0, dy: 0 });
                    bot.alive = true;
                }
                bot.ships.forEach((s, si) => drawShip(s, bot.ships.length, si === 0, false, bot));
                drawBullets(bot);
            });
            ctx.fillStyle = `rgba(0, 204, 255, ${Math.sin(frameCount * 0.05) * 0.2 + 0.3})`;
            ctx.font = '24px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('TopDownSpace', canvas.width / 2, canvas.height / 2 - 50);
        } else if (gameState === 'countdown' || gameState === 'playing') {
            if (gameState === 'countdown') {
                const elapsed = Date.now() - countdownStart;
                countdownValue = Math.max(0, Math.ceil(3 - elapsed / 1000));
                if (elapsed > 4000) gameState = 'playing';
            }

            players.forEach((p, i) => updatePlayer(p, i, false, deltaTime));
            spawnPowerUps();
            updatePowerUps();
            updateAsteroids(deltaTime);
            checkCollisions();

            players.forEach((p, i) => {
                if (p.alive && p.ships.length > 0) {
                    p.ships.forEach((s, si) => drawShip(s, p.ships.length, si === 0, !p.isBot, p));
                    drawBullets(p);
                }
            });

            if (modules.chaosMode) {
                chaosTimer += deltaTime;
                if (chaosTimer >= 30) {
                    triggerChaosEvent();
                    chaosTimer = 0;
                }
            }

            updateParticles(deltaTime);
            drawDamageFormationPowerUp();

            if (modules.separation) {
                const midX = canvas.width / 2;
                const midY = canvas.height / 2;
                const quarters = [0, 1, 2, 3].map(q => players.filter(p => p.alive && p.ships.length > 0 && p.quarter === q).length);
                ctx.strokeStyle = '#ff3333';
                ctx.lineWidth = 2;
                if (quarters.some(q => q > 1)) {
                    ctx.beginPath();
                    ctx.moveTo(midX, 0);
                    ctx.lineTo(midX, canvas.height);
                    ctx.moveTo(0, midY);
                    ctx.lineTo(canvas.width, midY);
                    ctx.stroke();
                } else if (quarters.filter(q => q === 1).length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(midX, 0);
                    ctx.lineTo(midX, canvas.height);
                    ctx.stroke();
                }
            }

            if (gameState === 'countdown') {
                ctx.fillStyle = '#ffffff';
                ctx.font = '48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(countdownValue > 0 ? countdownValue : 'GO!', canvas.width / 2, canvas.height / 2);
                if (countdownValue === 0) playSound(800, 0.3, 'sine', 0.3); // Start beep
            }

            const alivePlayers = players.filter(p => p.alive && p.ships.length > 0);
            if (alivePlayers.length <= 1 && gameState === 'playing') {
                gameState = 'victory';
                victoryScreen.style.display = 'flex';
                victoryDisplayTime = Date.now(); // Set the time when victory screen appears
                if (alivePlayers.length === 1) {
                    winnerText.textContent = `${alivePlayers[0].isBot ? 'AI' : 'Pilot'} ${players.indexOf(alivePlayers[0]) + 1} Wins!`;
                } else {
                    winnerText.textContent = 'No Winner!';
                }
                playSound(1200, 1.0, 'triangle', 0.3); // Victory fanfare
            }

            uiPanel.innerHTML = '';
            players.forEach((p, i) => {
                if (p.alive && p.ships.length > 0) {
                    const totalHP = getTotalHP(p);
                    const maxHP = p.ships.length * (modules.oneShot ? 1 : (modules.doubleHealth ? 2000 : 1000));
                    const hpPercent = (totalHP / maxHP * 100).toFixed(1);
                    const div = document.createElement('div');
                    div.style.color = p.traitColor;
                    div.textContent = `${p.isBot ? 'AI' : 'Pilot'} ${i + 1}: ${p.ships.length} ships, HP ${hpPercent}%${modules.threeLives ? `, Lives: ${p.lives}` : ''}`;
                    uiPanel.appendChild(div);
                }
            });
            eliminations.forEach((e, i) => {
                if (Date.now() - e.time < 5000) {
                    const div = document.createElement('div');
                    div.style.color = '#ff3333';
                    div.textContent = `${e.name} eliminated`;
                    uiPanel.appendChild(div);
                } else {
                    eliminations.splice(i, 1);
                }
            });
        }

        requestAnimationFrame(gameLoop);
    }

    window.onload = () => {
        gameContainer = document.getElementById('gameContainer');
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        menu = document.getElementById('menu');
        botMenu = document.getElementById('botMenu');
        difficultyMenu = document.getElementById('difficultyMenu');
        moduleMenu = document.getElementById('moduleMenu');
        victoryScreen = document.getElementById('victoryScreen');
        winnerText = document.getElementById('winnerText');
        uiPanel = document.getElementById('uiPanel');

        const squareSize = Math.min(gameContainer.clientWidth - sidebarWidth, gameContainer.clientHeight);
        canvas.width = squareSize;
        canvas.height = squareSize;

        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (gameState === 'victory' && Date.now() - victoryDisplayTime >= 3000) {
                restartGame(); // Only restart after 3 seconds
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        initMenuBots();
        requestAnimationFrame(gameLoop);
    };
</script>
</body>
</html>
